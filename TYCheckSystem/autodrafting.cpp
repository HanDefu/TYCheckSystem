//==============================================================================
//  WARNING!!  This file is overwritten by the Block UI Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  C:\codeguangzhou\install\application\autodrafting.cpp
//
//        This file was generated by the NX Block UI Styler
//        Created by: Administrator
//              Version: NX 10
//              Date: 03-18-2019  (Format: mm-dd-yyyy)
//              Time: 12:31 (Format: hh-mm)
//
//==============================================================================

//==============================================================================
//  Purpose:  This TEMPLATE file contains C++ source to guide you in the
//  construction of your Block application dialog. The generation of your
//  dialog file (.dlx extension) is the first step towards dialog construction
//  within NX.  You must now create a NX Open application that
//  utilizes this file (.dlx).
//
//  The information in this file provides you with the following:
//
//  1.  Help on how to load and display your Block UI Styler dialog in NX
//      using APIs provided in NXOpen.BlockStyler namespace
//  2.  The empty callback methods (stubs) associated with your dialog items
//      have also been placed in this file. These empty methods have been
//      created simply to start you along with your coding requirements.
//      The method name, argument list and possible return values have already
//      been provided for you.
//==============================================================================

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include "autodrafting.hpp"
#include "Common_UI.h"
#include <uf_disp.h>
using namespace NXOpen;
using namespace NXOpen::BlockStyler;

VecNXStringVector techData;

#define UF_CALL(X) (report_error( __FILE__, __LINE__, #X, (X)))

/*ARGSUSED*/
static int report_error( char *file, int line, char *call, int irc)
{
    if (irc)
    {
        char err[133],
             msg[133];

        sprintf(msg, "*** ERROR code %d at line %d in %s:\n+++ ",
            irc, line, file);
        UF_get_fail_message(irc, err);

    /*  NOTE:  UF_print_syslog is new in V18 */

        UF_print_syslog(msg, FALSE);
        UF_print_syslog(err, FALSE);
        UF_print_syslog("\n", FALSE);
        UF_print_syslog(call, FALSE);
        UF_print_syslog(";\n", FALSE);

        if (!UF_UI_open_listing_window())
        {
            UF_UI_write_listing_window(msg);
            UF_UI_write_listing_window(err);
            UF_UI_write_listing_window("\n");
            UF_UI_write_listing_window(call);
            UF_UI_write_listing_window(";\n");
        }
    }

    return(irc);
}

#define WRITE(X)   UF_UI_open_listing_window(); UF_UI_write_listing_window(X)

#define WRITE_D(X) (write_integer_to_listing_window(#X, X))
#define WRITENZ(X) if (X != 0) (write_integer_to_listing_window(#X, X))

/*ARGSUSED*/
static void write_integer_to_listing_window(char *title, int n)
{
    char
        msg[UF_UI_MAX_STRING_LEN+1];

    UF_CALL(UF_UI_open_listing_window());
    sprintf(msg, "%s = %d\n", title, n);
    UF_CALL(UF_UI_write_listing_window(msg));
}

/*ARGSUSED*/
static int mask_for_bodies(UF_UI_selection_p_t select, void *type)
{
    /*UF_UI_mask_t
        mask = { UF_solid_type, 0, UF_UI_SEL_FEATURE_BODY };

    if (!UF_CALL(UF_UI_set_sel_mask(select,
            UF_UI_SEL_MASK_CLEAR_AND_ENABLE_SPECIFIC, 1, &mask)))
        return (UF_UI_SEL_SUCCESS);
    else
        return (UF_UI_SEL_FAILURE);*/
    return (UF_UI_SEL_SUCCESS);
}

/*ARGSUSED*/
static int select_bodies(char *prompt, tag_t **bodies)
{
    int
        cnt,
        ii,
        resp;

    UF_CALL(UF_UI_select_with_class_dialog("Select solids or sheets", prompt,
        UF_UI_SEL_SCOPE_ANY_IN_ASSEMBLY, mask_for_bodies, NULL, &resp, &cnt,
        bodies));

    //for (ii = 0; ii < cnt; ii++)
        //UF_CALL(UF_DISP_set_highlight((*bodies)[ii], FALSE));

    return cnt;

}

/*ARGSUSED*/
static logical prompt_for_a_number(char *prompt, char *item, double *number)
{
    int
        irc,
        resp;
    char
        menu[1][16];
    double
        da[1];

    strncpy(&menu[0][0], item, 16);
    menu[0][15] = '\0';
    da[0] = *number;

    resp = uc1609(prompt, menu, 1, da, &irc);
    if (resp == 3 || resp == 4)
    {
        *number = da[0];
        return TRUE;
    }
    else return FALSE;

}

/*ARGSUSED*/
static void do_it(void)
{
    int
        inx = 0,
        num_bodies = 0;
    tag_t
        * body_tags = NULL,
        *tags = NULL;
    char  factors[3][ UF_MAX_EXP_BUFSIZE ]={"2","2","2"};
    double
        new_scale = 0.;
    
    while((( num_bodies = select_bodies("Select bodies", &body_tags)) > 0 ) &&
           ( prompt_for_a_number("New Scale?", "new Scale:", &new_scale)))
    {
        sprintf(factors[0], "%f", new_scale );
        
        UF_CALL( UF_MODL_create_scale( UF_SCALE_TYPE_UNIFORM, body_tags,
                                       num_bodies, NULL_TAG, NULL_TAG, 
                                       NULL_TAG, factors,  &tags ));
        
        WRITE( "New tags for scale feature bodies:\n" );
        
        for( inx = 0; inx < num_bodies; inx++ )
        {
            WRITE_D( tags[inx] );
        }
        
        UF_free( body_tags );
        UF_free( tags );
    }
    
}
//------------------------------------------------------------------------------
// Initialize static variables
//------------------------------------------------------------------------------
Session *(autodrafting::theSession) = NULL;
UI *(autodrafting::theUI) = NULL;
//------------------------------------------------------------------------------
// Constructor for NX Styler class
//------------------------------------------------------------------------------
autodrafting::autodrafting()
{
    try
    {
        // Initialize the NX Open C++ API environment
        autodrafting::theSession = NXOpen::Session::GetSession();
        autodrafting::theUI = UI::GetUI();
        theDlxFileName = "autodrafting.dlx";
        theDialog = autodrafting::theUI->CreateDialog(theDlxFileName);
        // Registration of callback functions
        //theDialog->AddApplyHandler(make_callback(this, &autodrafting::apply_cb));
        theDialog->AddOkHandler(make_callback(this, &autodrafting::ok_cb));
        theDialog->AddUpdateHandler(make_callback(this, &autodrafting::update_cb));
        theDialog->AddCancelHandler(make_callback(this, &autodrafting::cancel_cb));
        theDialog->AddInitializeHandler(make_callback(this, &autodrafting::initialize_cb));
        theDialog->AddDialogShownHandler(make_callback(this, &autodrafting::dialogShown_cb));
        theDialog->AddEnableOKButtonHandler(make_callback(this, &autodrafting::enableOKButton_cb));
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        throw;
    }
}

bool autodrafting::enableOKButton_cb()
{
    try
    {
        //---- Enter your callback code here -----
        std::vector<Node*> SelectedNodes;
		NXOpen::BlockStyler::Node * treeNode = tree_control0->RootNode();
		if( NULL != treeNode )
		{
			return true;
		}
        else
        {
            return false;
        }
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        autodrafting::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return true;
}
//------------------------------------------------------------------------------
// Destructor for NX Styler class
//------------------------------------------------------------------------------
autodrafting::~autodrafting()
{
    if (theDialog != NULL)
    {
        delete theDialog;
        theDialog = NULL;
    }
}
//------------------------------- DIALOG LAUNCHING ---------------------------------
//
//    Before invoking this application one needs to open any part/empty part in NX
//    because of the behavior of the blocks.
//
//    Make sure the dlx file is in one of the following locations:
//        1.) From where NX session is launched
//        2.) $UGII_USER_DIR/application
//        3.) For released applications, using UGII_CUSTOM_DIRECTORY_FILE is highly
//            recommended. This variable is set to a full directory path to a file 
//            containing a list of root directories for all custom applications.
//            e.g., UGII_CUSTOM_DIRECTORY_FILE=$UGII_ROOT_DIR\menus\custom_dirs.dat
//
//    You can create the dialog using one of the following way:
//
//    1. USER EXIT
//
//        1) Create the Shared Library -- Refer "Block UI Styler programmer's guide"
//        2) Invoke the Shared Library through File->Execute->NX Open menu.
//
//------------------------------------------------------------------------------
void GZ_PART_DRAFT_Main()
{
    autodrafting *theautodrafting = NULL;
    try
    {
        //return do_it();
        theautodrafting = new autodrafting();
        // The following method shows the dialog immediately
        theautodrafting->Show();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        autodrafting::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    if(theautodrafting != NULL)
    {
        delete theautodrafting;
        theautodrafting = NULL;
    }
}

//------------------------------------------------------------------------------
// This method specifies how a shared image is unloaded from memory
// within NX. This method gives you the capability to unload an
// internal NX Open application or user  exit from NX. Specify any
// one of the three constants as a return value to determine the type
// of unload to perform:
//
//
//    Immediately : unload the library as soon as the automation program has completed
//    Explicitly  : unload the library from the "Unload Shared Image" dialog
//    AtTermination : unload the library when the NX session terminates
//
//
// NOTE:  A program which associates NX Open applications with the menubar
// MUST NOT use this option since it will UNLOAD your NX Open application image
// from the menubar.
//------------------------------------------------------------------------------

int autodrafting::Show()
{
    try
    {
        theDialog->Show();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        autodrafting::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}

//------------------------------------------------------------------------------
//---------------------Block UI Styler Callback Functions--------------------------
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//Callback Name: initialize_cb
//------------------------------------------------------------------------------
void autodrafting::initialize_cb()
{
    try
    {
        group1 = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group1"));
        projectName = dynamic_cast<NXOpen::BlockStyler::StringBlock*>(theDialog->TopBlock()->FindBlock("projectName"));
        projectNO = dynamic_cast<NXOpen::BlockStyler::StringBlock*>(theDialog->TopBlock()->FindBlock("projectNO"));
        drawingName = dynamic_cast<NXOpen::BlockStyler::StringBlock*>(theDialog->TopBlock()->FindBlock("drawingName"));
        drawingNO = dynamic_cast<NXOpen::BlockStyler::StringBlock*>(theDialog->TopBlock()->FindBlock("drawingNO"));
        DesignDate = dynamic_cast<NXOpen::BlockStyler::StringBlock*>(theDialog->TopBlock()->FindBlock("DesignDate"));
        enumType = dynamic_cast<NXOpen::BlockStyler::Enumeration*>(theDialog->TopBlock()->FindBlock("enumType"));
        toggleHide = dynamic_cast<NXOpen::BlockStyler::Toggle*>(theDialog->TopBlock()->FindBlock("toggleHide"));
        multiline_string0 = dynamic_cast<NXOpen::BlockStyler::MultilineString*>(theDialog->TopBlock()->FindBlock("multiline_string0"));
        scrolledWindow = dynamic_cast<NXOpen::BlockStyler::ScrolledWindow*>(theDialog->TopBlock()->FindBlock("scrolledWindow"));
        tree_control0 = dynamic_cast<NXOpen::BlockStyler::Tree*>(theDialog->TopBlock()->FindBlock("tree_control0"));
        coord_system0 = dynamic_cast<NXOpen::BlockStyler::SpecifyCSYS*>(theDialog->TopBlock()->FindBlock("coord_system0"));
        buttonApplyCSYS = dynamic_cast<NXOpen::BlockStyler::Button*>(theDialog->TopBlock()->FindBlock("buttonApplyCSYS"));
        buttonDelete = dynamic_cast<NXOpen::BlockStyler::Button*>(theDialog->TopBlock()->FindBlock("buttonDelete"));
        group = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group"));
        bodySelect0 = dynamic_cast<NXOpen::BlockStyler::BodyCollector*>(theDialog->TopBlock()->FindBlock("bodySelect0"));
        enumFrameType = dynamic_cast<NXOpen::BlockStyler::Enumeration*>(theDialog->TopBlock()->FindBlock("enumFrameType"));
        doubleDwgScale = dynamic_cast<NXOpen::BlockStyler::DoubleBlock*>(theDialog->TopBlock()->FindBlock("doubleDwgScale"));
        nativeFolderBrowser01 = dynamic_cast<NXOpen::BlockStyler::FolderSelection*>(theDialog->TopBlock()->FindBlock("nativeFolderBrowser01"));
        //------------------------------------------------------------------------------
        //Registration of Treelist specific callbacks
        //------------------------------------------------------------------------------
        //tree_control0->SetOnExpandHandler(make_callback(this, &autodrafting::OnExpandCallback));
        
        //tree_control0->SetOnInsertColumnHandler(make_callback(this, &autodrafting::OnInsertColumnCallback));
        
        //tree_control0->SetOnInsertNodeHandler(make_callback(this, &autodrafting::OnInsertNodeCallback));
        
        //tree_control0->SetOnDeleteNodeHandler(make_callback(this, &autodrafting::OnDeleteNodeCallback));
        
        //tree_control0->SetOnPreSelectHandler(make_callback(this, &autodrafting::OnPreSelectCallback));
        
        tree_control0->SetOnSelectHandler(make_callback(this, &autodrafting::OnSelectCallback));
        
        //tree_control0->SetOnStateChangeHandler(make_callback(this, &autodrafting::OnStateChangeCallback));
        
        //tree_control0->SetToolTipTextHandler(make_callback(this, &autodrafting::ToolTipTextCallback));
        
        //tree_control0->SetColumnSortHandler(make_callback(this, &autodrafting::ColumnSortCallback));
        
        //tree_control0->SetStateIconNameHandler(make_callback(this, &autodrafting::StateIconNameCallback));
        
        //tree_control0->SetOnBeginLabelEditHandler(make_callback(this, &autodrafting::OnBeginLabelEditCallback));
        
        //tree_control0->SetOnEndLabelEditHandler(make_callback(this, &autodrafting::OnEndLabelEditCallback));
        
        //tree_control0->SetOnEditOptionSelectedHandler(make_callback(this, &autodrafting::OnEditOptionSelectedCallback));
        
        //tree_control0->SetAskEditControlHandler(make_callback(this, &autodrafting::AskEditControlCallback));
        
        //tree_control0->SetOnMenuHandler(make_callback(this, &autodrafting::OnMenuCallback));
        
        //tree_control0->SetOnMenuSelectionHandler(make_callback(this, &autodrafting::OnMenuSelectionCallback));
        
        //tree_control0->SetIsDropAllowedHandler(make_callback(this, &autodrafting::IsDropAllowedCallback));
        
        //tree_control0->SetIsDragAllowedHandler(make_callback(this, &autodrafting::IsDragAllowedCallback));
        
        //tree_control0->SetOnDropHandler(make_callback(this, &autodrafting::OnDropCallback));
        
        //tree_control0->SetOnDropMenuHandler(make_callback(this, &autodrafting::OnDropMenuCallback));
        
        //tree_control0->SetOnDefaultActionHandler(make_callback(this, &autodrafting::OnDefaultAction));
        
        //------------------------------------------------------------------------------
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        autodrafting::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}
void autodrafting::ReadExcelConfigData( )
{
	/*BasicExcel excel;
    char regfile[256]="";
    sheetNames.clear();
    //sheetNames.push_back("全部");
    sprintf(regfile,"%s\\Parameter\\Config.xls",getenv("UGII_USER_DIR"));
	bool isOk = excel.Load(regfile);
	if( isOk )
	{
        int num = excel.GetTotalWorkSheets();
        for( int idx = 0; idx < num; ++idx )
        {
            const wchar_t* sheetName = excel.GetUnicodeSheetName(idx);
			sheetNames.push_back(WCHARTOCHAR(sheetName));
        }
	}*/
	return;
}

NXString GetDateStr()
{
    time_t timep;
    struct tm *time_ptr;
    time(&timep);
    time_ptr = localtime(&timep);
    char timeStr[32] = "";
    sprintf_s(timeStr,"%d%02d%02d",time_ptr->tm_year+1900, time_ptr->tm_mon+1, time_ptr->tm_mday);
    return NXString(timeStr);
}
//------------------------------------------------------------------------------
//Callback Name: dialogShown_cb
//This callback is executed just before the dialog launch. Thus any value set 
//here will take precedence and dialog will be launched showing that value. 
//------------------------------------------------------------------------------
void autodrafting::dialogShown_cb()
{
    try
    {
        //---- Enter your callback code here -----
		char file_name[UF_CFI_MAX_PATH_NAME_SIZE]="";
		char dspec[MAX_FSPEC_BUFSIZE]="";
		char fname[UF_CFI_MAX_FILE_NAME_BUFSIZE]="";
		StlTagVector solidboies;
        /*StlDoubVector scalelist;
        scalelist.push_back(1);
        scalelist.push_back(2);
        scalelist.push_back(3);
        scalelist.push_back(4);
        scalelist.push_back(5);*/
        //ReadExcelConfigData();
        //enumType->GetProperties()->SetEnumMembers("Value",sheetNames);
		//CF_GetCurrentPartSolidBodies(solidboies);
		CreateUITree(solidboies,true);
        //doubleDwgScale->GetProperties()->SetDoubleVector("ComboOptions",scalelist);

        char attriValue2[133] = "";
        tag_t part = UF_ASSEM_ask_work_part();
		/*USER_ask_obj_string_attr( part , "材料编号" , attriValue2 );
		drawingNO->GetProperties()->SetString("Value",attriValue2);*/

        USER_ask_obj_string_attr( part , "工程名称" , attriValue2 );
        projectName->GetProperties()->SetString("Value",attriValue2);
        USER_ask_obj_string_attr( part , "工程编号" , attriValue2 );
        projectNO->GetProperties()->SetString("Value",attriValue2);

        SetTypeUI();
        //drawingNO->GetProperties()->SetString("Value","图号");
        DesignDate->GetProperties()->SetString("Value",GetDateStr());
		tag_t disPart = UF_PART_ask_display_part();
		UF_PART_ask_part_name (disPart, file_name );
		uc4576(file_name,2,dspec,fname);
		nativeFolderBrowser01->GetProperties()->SetString("Path",dspec);
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        autodrafting::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

int autodrafting::CreateUITree( StlTagVector& bodies, logical insertCol )
{
    StlNXStringVector ColumnNames;
    ColumnNames.push_back("图号");
    ColumnNames.push_back("图框");
    ColumnNames.push_back("隐藏/显示");
    int nodeCount = 1;
    if( insertCol )
    {
        for( int idx = 0; idx < ColumnNames.size(); ++idx )
        {
            tree_control0->InsertColumn( idx, ColumnNames[idx], 135 );
            tree_control0->SetColumnSortable( idx, false );
            //treeID->SetColumnResizePolicy(idx,Tree::ColumnResizePolicyResizeWithContents);
        }
        //tree_control0->SetColumnResizePolicy(0,Tree::ColumnResizePolicyResizeWithContents);
    }
    return 0;
}

static void export_sheet_to_acad_dwg2d( char* inputfile, char* outputfile, NXString& drawingName )
{
	NXOpen::Session *theSession = NXOpen::Session::GetSession();
    NXOpen::Part *workPart(theSession->Parts()->Work());
    NXOpen::Part *displayPart(theSession->Parts()->Display());

	int status = 0;
	UF_CFI_ask_file_exist(outputfile,&status);
	if( 0 == status )
	{
		uc4561(outputfile,0);
	}
	char *p_env;
    char dwgdef[MAX_FSPEC_SIZE];
    p_env = getenv("UGII_USER_DIR");
    strcpy(dwgdef,p_env);
    strcat(dwgdef,"\\application\\dxfdwg.def");
  
    NXOpen::DxfdwgCreator *dxfdwgCreator1;
    dxfdwgCreator1 = theSession->DexManager()->CreateDxfdwgCreator();
    
    dxfdwgCreator1->SetExportData(NXOpen::DxfdwgCreator::ExportDataOptionDrawing);
    
    dxfdwgCreator1->SetAutoCADRevision(NXOpen::DxfdwgCreator::AutoCADRevisionOptionsR2004);
    
    dxfdwgCreator1->SetViewEditMode(true);
    
    dxfdwgCreator1->SetFlattenAssembly(true);
    
    dxfdwgCreator1->ObjectTypes()->SetCurves(true);
    
    dxfdwgCreator1->ObjectTypes()->SetAnnotations(true);
    
    dxfdwgCreator1->ObjectTypes()->SetStructures(true);
    
    dxfdwgCreator1->SetFlattenAssembly(false);
    
    dxfdwgCreator1->SetSettingsFile(dwgdef);
    
    dxfdwgCreator1->SetOutputFileType(NXOpen::DxfdwgCreator::OutputFileTypeOptionDwg);
    
    dxfdwgCreator1->SetInputFile(inputfile);
    
    dxfdwgCreator1->SetOutputFile(outputfile);
    
    dxfdwgCreator1->SetExportSplinesAs(NXOpen::DxfdwgCreator::ExportSplinesAsOptionsPolyline2D);
    
    //dxfdwgCreator1->SetTextFontMappingFile("C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\Admi0A188E06nlb3.txt");
    
    dxfdwgCreator1->SetWidthFactorMode(NXOpen::DxfdwgCreator::WidthfactorMethodOptionsAutomaticCalculation);
    
    //dxfdwgCreator1->SetCrossHatchMappingFile("C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\Admi0A188E06nlb4.txt");
    
    //dxfdwgCreator1->SetLineFontMappingFile("C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\Admi0A188E06nlb5.txt");
    
    dxfdwgCreator1->SetLayerMask("1-256");
    
    dxfdwgCreator1->SetDrawingList( drawingName );
    
    NXOpen::NXObject *nXObject1;
    nXObject1 = dxfdwgCreator1->Commit();
    
    dxfdwgCreator1->Destroy();
	int count = 0;
    UF_CFI_ask_file_exist(outputfile,&status);
    while( count < 300 && 1 == status)
    {
        _sleep(500);
        count++;
        UF_CFI_ask_file_exist(outputfile,&status);
    }
}

static tag_t  CreateDWGPart( )
{
	tag_t partTag = NULL_TAG;
	char sFilePath[UF_CFI_MAX_PATH_NAME_SIZE]="";
	char file_name[UF_CFI_MAX_PATH_NAME_SIZE]="";
	char fname[_MAX_FNAME];

	NXOpen::Session *theSession = NXOpen::Session::GetSession();

	tag_t disPart = UF_PART_ask_display_part();
	tag_t rootocc = UF_ASSEM_ask_root_part_occ(disPart);
	UF_PART_ask_part_name (disPart, file_name );
	char *p = strstr(file_name,".prt");
	if( p != NULL )
	{
		*p='\0';
	}
	char *p_env = getenv("UGII_USER_DIR");
	char srcspc[MAX_FSPEC_SIZE]="";
	char desspc[MAX_FSPEC_SIZE]="";
	sprintf(srcspc,"%s\\templates\\gz_dwg.prt",p_env);
	sprintf(desspc,"%s_dwg.prt",file_name);
	int status = uc4567( srcspc,desspc,UF_CFI_COPY_ALWAYS_REPLACE,0,2);
	UF_CFI_ask_file_exist(desspc,&status);
	if(0  == status )
	{
		UF_PART_load_status_t error_status;
		tag_t new_drawing_tag = NULL_TAG;
		UF_PART_open(desspc,&partTag, &error_status);
		//UF_ASSEM_set_work_part_quietly(partTag,&disPart);
		UF_PART_free_load_status(&error_status);
		if(partTag != NULL_TAG)
		{
			theSession->ApplicationSwitchImmediate("UG_APP_DRAFTING");
		}
	}
	return partTag;
}

tag_t GetReferencesetBody(tag_t part,NXString& refsetName)
{
	tag_t body = NULL_TAG;
	tag_t refset = NULL_TAG;
  	UF_OBJ_cycle_by_name_and_type(part, refsetName.GetLocaleText(),UF_reference_set_type, FALSE, &refset);
	if( refset != NULL_TAG )
	{
		int n_members = 0;
		tag_t * members = NULL;
		UF_ASSEM_ask_ref_set_members( refset , & n_members , & members ) ;
		for( int i = 0 ; i < n_members ; i ++ )
		{
			int type = 0, subtype = 0;
			UF_OBJ_ask_type_and_subtype( members[ i ] , & type , & subtype ) ;
			if (type == UF_solid_type && subtype == UF_solid_body_subtype &&
				UF_OBJ_ALIVE == UF_OBJ_ask_status( members[ i ] ) )
			{
				body = members[i];
			}
		}
		UF_free( members ) ;
	}
	return body;
}

void GetTopViewProjectDirection( tag_t partTag, NXString& refset,double dir[3][3] )
{
	tag_t part = partTag;
	dir[0][0] = 1;
	dir[0][1] = 0;
	dir[0][2] = 0;
	dir[1][0] = 0;
	dir[1][1] = 1;
	dir[1][2] = 0;
	dir[2][0] = 0;
	dir[2][1] = 0;
	dir[2][2] = 1;
	if(UF_ASSEM_is_occurrence(partTag))
	{
		part = UF_ASSEM_ask_prototype_of_occ(partTag);
	}
	tag_t body = GetReferencesetBody(part,refset);
	if( NULL_TAG != body )
	{
		char VZx[133]="",VZy[133]="",VZz[133]="";
		char VXx[133]="",VXy[133]="",VXz[133]="";
		int irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_NORMAL_DIR_X,VZx);
		if( 0 == irc )
		{
			irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_NORMAL_DIR_Y,VZy);
		}
		if( 0 == irc )
		{
			irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_NORMAL_DIR_Z,VZz);
		}
		if( 0 == irc )
		{
			irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_X_DIR_X,VXx);
		}
		if( 0 == irc )
		{
			irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_X_DIR_Y,VXy);
		}
		if( 0 == irc )
		{
			irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_X_DIR_Z,VXz);
		}
		if( 0 == irc )
		{
			dir[0][0] = atof(VXx);
			dir[0][1] = atof(VXy);
			dir[0][2] = atof(VXz);
			dir[2][0] = atof(VZx);
			dir[2][1] = atof(VZy);
			dir[2][2] = atof(VZz);
			double tol = 0;
			UF_MODL_ask_distance_tolerance(&tol);
			UF_VEC3_cross(dir[2], dir[0], dir[1]);
			/*UF_CALL(UF_VEC3_unitize(dir[0], tol, &mag, &csys[0]));
			UF_CALL(UF_VEC3_unitize(dir[1], tol, &mag, &csys[3]));
			UF_CALL(UF_VEC3_unitize(dir[2], tol, &mag, &csys[6]));*/
		}
	}
}

static tag_t CreateBaseView(tag_t partTag, NXString viewType, NXString& refset,Point3d& viewRefPoint, double stdscale,double sheetlen,double sheethei  )
{
	tag_t viewTag = NULL_TAG;

	NXOpen::Session *theSession = NXOpen::Session::GetSession();
    NXOpen::Part *workPart(theSession->Parts()->Work());

    NXOpen::Drawings::BaseView *nullNXOpen_Drawings_BaseView(NULL);
    NXOpen::Drawings::BaseViewBuilder *baseViewBuilder1;
    baseViewBuilder1 = workPart->DraftingViews()->CreateBaseViewBuilder(nullNXOpen_Drawings_BaseView);
    
    baseViewBuilder1->Placement()->SetAssociative(true);
    
    char part_fspec[MAX_FSPEC_SIZE+1] = "";
	tag_t part = partTag;
	if(UF_ASSEM_is_occurrence(partTag))
	{
		part = UF_ASSEM_ask_prototype_of_occ(partTag);
	}
    UF_PART_ask_part_name(part,part_fspec);

	Part *part1(dynamic_cast<Part *>(NXOpen::NXObjectManager::Get(part)));
    bool loadStatus1;
    loadStatus1 = part1->IsFullyLoaded();
	if( !loadStatus1 )
		part1->LoadFully();
    
    NXOpen::ModelingView *modelingView2(dynamic_cast<NXOpen::ModelingView *>(part1->ModelingViews()->FindObject(viewType)));
    baseViewBuilder1->SelectModelView()->SetSelectedView(modelingView2);
    
    NXOpen::Assemblies::Arrangement *nullNXOpen_Assemblies_Arrangement(NULL);
    baseViewBuilder1->Style()->ViewStyleBase()->Arrangement()->SetSelectedArrangement(nullNXOpen_Assemblies_Arrangement);
    
    baseViewBuilder1->Style()->ViewStyleBase()->SetPart(part1);
    
    baseViewBuilder1->Style()->ViewStyleBase()->SetPartName(NXString(part_fspec));
    
	NXOpen::NXObject *nXObject2;
	//logical adjust = false;
	//NXOpen::Vector3d vec1(0.0, 0.0, 1.0);
	//NXOpen::Vector3d vec2(1.0, 0.0, 0.0);
	if( 0 == strcmp("Top",viewType.GetText()) )
	{
		/*workPart->DrawingSheets()->CurrentDrawingSheet();
		Drawings::DrawingSheet *drawingSheet1= workPart->DrawingSheets()->CurrentDrawingSheet();
		Drawings::DrawingSheetBuilder *drawingSheetBuilder1;
		drawingSheetBuilder1 = workPart->DrawingSheets()->DrawingSheetBuilder(drawingSheet1);
		double sheetlen = drawingSheetBuilder1->Length();
		double sheethei = drawingSheetBuilder1->Height();
		drawingSheetBuilder1->Destroy();*/

		NXOpen::Direction *direction1;
		NXOpen::Point3d origin1(0.0, 0.0, 0.0);
		NXOpen::Vector3d vector1(0.0, 0.0, 1.0);
		NXOpen::Vector3d vector2(1.0, 0.0, 0.0);
		double dir[3][3]={0};
		GetTopViewProjectDirection(partTag,refset,dir);
		vector1.X = dir[2][0];
		vector1.Y = dir[2][1];
		vector1.Z = dir[2][2];
		vector2.X = dir[0][0];
		vector2.Y = dir[0][1];
		vector2.Z = dir[0][2];
		/*tag_t body = GetReferencesetBody(part,refset);
		if( NULL_TAG != body )
		{
			char VZx[133]="",VZy[133]="",VZz[133]="";
			char VXx[133]="",VXy[133]="",VXz[133]="";
			int irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_NORMAL_DIR_X,VZx);
			if( 0 == irc )
			{
				irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_NORMAL_DIR_Y,VZy);
			}
			if( 0 == irc )
			{
				irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_NORMAL_DIR_Z,VZz);
			}
			if( 0 == irc )
			{
				irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_X_DIR_X,VXx);
			}
			if( 0 == irc )
			{
				irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_X_DIR_Y,VXy);
			}
			if( 0 == irc )
			{
				irc = Roy_ask_obj_string_attr(body,ATTR_DRAFTING_X_DIR_Z,VXz);
			}
			if( 0 == irc )
			{
				vector1.X = atof(VZx);
				vector1.Y = atof(VZy);
				vector1.Z = atof(VZz);
				vector2.X = atof(VXx);
				vector2.Y = atof(VXy);
				vector2.Z = atof(VXz);
			}
		}*/
		
		direction1 = workPart->Directions()->CreateDirection(origin1, vector1, NXOpen::SmartObject::UpdateOptionAfterModeling);
		baseViewBuilder1->Style()->ViewStyleOrientation()->Ovt()->SetNormalDirection(direction1);

		NXOpen::Direction *direction2;
		direction2 = workPart->Directions()->CreateDirection(origin1, vector2, NXOpen::SmartObject::UpdateOptionAfterModeling);
		baseViewBuilder1->Style()->ViewStyleOrientation()->Ovt()->SetXDirection(direction2);

        viewRefPoint.X = sheetlen/2;
		viewRefPoint.Y = sheethei/2;
		viewRefPoint.Z = 0;
	}
	else
	{
		//baseViewBuilder1->Scale()->SetDenominator(1.0);
	}
	baseViewBuilder1->Scale()->SetDenominator(stdscale);
    baseViewBuilder1->Placement()->Placement()->SetValue(NULL, workPart->Views()->WorkView(), viewRefPoint);
	
	nXObject2 = baseViewBuilder1->Commit();
    viewTag = nXObject2->Tag();

	baseViewBuilder1->Destroy();

	/*if(adjust)
		AdjustViewDirection(viewTag,vec1,vec2);*/
    return viewTag;
}

static int ROY_UF_VIEW_ask_xy_clip(tag_t view_tag ,double scale, double xy_clip_bounds[4] )
{
	double xy_boud[4] = {0,0,0,0};
	int irc = UF_VIEW_ask_xy_clip(view_tag,xy_boud);
	for( int idx = 0; idx < 4; idx++ )
	{
		xy_clip_bounds[idx] = xy_boud[idx]/scale;
	}
	return irc;
}

static tag_t CreateProjectView( tag_t topView, const double x, const double y)
{
    Session *theSession = Session::GetSession();
    Part *workPart(theSession->Parts()->Work());
    Part *displayPart(theSession->Parts()->Display());
    Drawings::ProjectedView *nullDrawings_ProjectedView(NULL);
    Drawings::ProjectedViewBuilder *projectedViewBuilder1;
    projectedViewBuilder1 = workPart->DraftingViews()->CreateProjectedViewBuilder(nullDrawings_ProjectedView);
    
    //Drawings::BaseView *baseView1(dynamic_cast<Drawings::BaseView *>(workPart->DraftingViews()->FindObject("TOP@1")));
	Drawings::BaseView *baseView1(dynamic_cast<Drawings::BaseView *>(NXOpen::NXObjectManager::Get(topView)));

    projectedViewBuilder1->Parent()->View()->SetValue(baseView1);
    
    projectedViewBuilder1->Style()->ViewStyleDetail()->SetViewBoundaryWidth(Preferences::WidthOriginal);
    
    //projectedViewBuilder1->Style()->ViewStyleBase()->SetPartName("E:\\xingtai\\RYF140628-UG\\RYF140628-UG\\RYF140628-GAUGE\\RYF-test_dwg.prt");
    
    projectedViewBuilder1->Style()->ViewStyleDetail()->SetViewBoundaryWidth(Preferences::WidthNormal);
    
    projectedViewBuilder1->Style()->ViewStyleGeneral()->SetToleranceValue(0.213614);    
    
    projectedViewBuilder1->Placement()->AlignmentView()->SetValue(baseView1);
    
    Point3d point2(x, y, 0.0);
    projectedViewBuilder1->Placement()->Placement()->SetValue(NULL, workPart->Views()->WorkView(), point2);
    
    projectedViewBuilder1->Placement()->AlignmentView()->SetValue(baseView1);
    
    NXObject *nXObject3;
    nXObject3 = projectedViewBuilder1->Commit();
	tag_t viewTag = nXObject3->Tag();

    projectedViewBuilder1->Destroy();
	return viewTag;
}

static void MoveBaseView( tag_t viewTag ,double x, double y)
{
	Session *theSession = Session::GetSession();
    Part *workPart(theSession->Parts()->Work());

    NXOpen::Drawings::BaseViewBuilder *baseViewBuilder1;
    Drawings::BaseView *baseView1(dynamic_cast<Drawings::BaseView *>(NXOpen::NXObjectManager::Get(viewTag)));
    baseViewBuilder1 = workPart->DraftingViews()->CreateBaseViewBuilder(baseView1);

    Point3d point2(x, y, 0.0);
    baseViewBuilder1->Placement()->Placement()->SetValue(NULL, workPart->Views()->WorkView(), point2);
    
    NXObject *nXObject3;
    nXObject3 = baseViewBuilder1->Commit();
    baseViewBuilder1->Destroy();
}

static void MoveProjectView( tag_t projectview ,double x, double y)
{
	Session *theSession = Session::GetSession();
    Part *workPart(theSession->Parts()->Work());
    Drawings::ProjectedView *nullDrawings_ProjectedView(NULL);
    Drawings::ProjectedViewBuilder *projectedViewBuilder1;
    
	//Drawings::BaseView *baseView1(dynamic_cast<Drawings::BaseView *>(NXOpen::NXObjectManager::Get(topView)));
	Drawings::ProjectedView *projectView1(dynamic_cast<Drawings::ProjectedView *>(NXOpen::NXObjectManager::Get(projectview)));

	projectedViewBuilder1 = workPart->DraftingViews()->CreateProjectedViewBuilder(projectView1);

   /* projectedViewBuilder1->Parent()->View()->SetValue(baseView1);

	projectedViewBuilder1->Placement()->AlignmentView()->SetValue(baseView1);*/
    
    Point3d point2(x, y, 0.0);
    projectedViewBuilder1->Placement()->Placement()->SetValue(NULL, workPart->Views()->WorkView(), point2);
    
    //projectedViewBuilder1->Placement()->AlignmentView()->SetValue(baseView1);
    
    NXObject *nXObject3;
    nXObject3 = projectedViewBuilder1->Commit();
	//tag_t viewTag = nXObject3->Tag();

    projectedViewBuilder1->Destroy();
}

static int CreateBaseAndProjectViews( tag_t partTag, NXString& refset, double stdscale, tag_t &symbolView, tag_t &projectViewl,tag_t &projectViewr, double viewxbound[4],double& sug,double sheetlen,double sheethei)//6,75, x-6, y-36 v // 6,75, x-59, y-6 h
{
	Session *theSession = Session::GetSession();
    Part *workPart(theSession->Parts()->Work());
	NXOpen::Point3d point1(0, 0, 0.0);
	tag_t baseView = CreateBaseView(partTag,"Top",refset, point1,stdscale,sheetlen,sheethei);

    tag_t proto = partTag;
    tag_t currentDrawing = NULL_TAG;
    tag_t *comps = NULL;
    tag_t disp = UF_PART_ask_display_part();
    if(UF_ASSEM_is_occurrence(partTag))
        proto = UF_ASSEM_ask_prototype_of_occ(partTag);
    tag_t rootocc = UF_ASSEM_ask_root_part_occ(disp);
    int n = UF_ASSEM_ask_part_occ_children(rootocc, &comps);
    for( int idx = 0; idx < n; ++idx )
    {
        tag_t compPro = UF_ASSEM_ask_prototype_of_occ(comps[idx]);
        if( compPro == proto )
        {
            int err = 0;
            err = UF_ASSEM_replace_refset(1,&comps[idx],refset.GetLocaleText());
            tag_t baseView2 = CreateBaseView(partTag,"Top",refset, point1,stdscale,sheetlen,sheethei);
            UF_VIEW_delete(baseView,&err);
            baseView = baseView2;
        }
    }
    UF_DRAW_ask_current_drawing(&currentDrawing);
    UF_DRAW_upd_out_of_date_views(currentDrawing);
    UF_free(comps);
    //UF_DRAW_set_suppress_view_updat
             //UF_DRAW_update_one_view
    double sheetLen = point1.X*2;
    double sheetHei = point1.Y*2;
	projectViewl = CreateProjectView(baseView,point1.X, point1.Y-50);
    projectViewr = CreateProjectView(baseView,point1.X+50, point1.Y);
    tag_t IsometricView = CreateBaseView(partTag,"Isometric", refset,point1,stdscale,sheetlen,sheethei);
	double xy_boud1[4] = {0,0,0,0};
	double xy_boud2[4] = {0,0,0,0};
	double xy_boud3[4] = {0,0,0,0};
	double xy_boud4[4] = {0,0,0,0};
	ROY_UF_VIEW_ask_xy_clip(baseView,stdscale,xy_boud1);
	ROY_UF_VIEW_ask_xy_clip(projectViewl,stdscale,xy_boud2);
    ROY_UF_VIEW_ask_xy_clip(projectViewr,stdscale,xy_boud3);
    ROY_UF_VIEW_ask_xy_clip(IsometricView,stdscale,xy_boud4);
    double viewHei = xy_boud1[3]-xy_boud1[2] + xy_boud2[3]-xy_boud2[2];
    double viewLen = xy_boud1[1]-xy_boud1[0] + xy_boud3[1]-xy_boud3[0];
    double drawingareaHei = 0;
    double drawingareaLen = 0;
    double vlen2 = xy_boud1[1]-xy_boud1[0] + xy_boud4[1]-xy_boud4[0];
    double vhei2 = xy_boud3[3]-xy_boud3[2] + xy_boud4[3]-xy_boud4[2];
    if(sheetLen > sheetHei) //h
    {
        drawingareaLen = sheetLen-20-20;
        drawingareaHei = sheetHei-40-20;
    }
    else //v 
    {
        drawingareaLen = sheetLen-20-20;
        drawingareaHei = sheetHei-40-20;
    }
	if( vhei2 > viewHei )
		viewHei = vhei2;
	if( vlen2 > viewLen )
		viewLen = vlen2;
	if( viewHei >= drawingareaHei || viewLen >= drawingareaLen ) //adjust scale &&  stdscale < 19.9 || vhei2 >= drawingareaHei || vlen2 >= drawingareaLen 
    {
		int err = 0;//-->A3 UF_DRAW_set_drawing_info
        double sug1 = (viewLen-25.4)/(drawingareaLen-25.4);
        double sug2 = (viewHei-25.4)/(drawingareaHei-25.4);
        if( sug1 > sug2 )
            sug = sug1;
        else
            sug = sug2;
		UF_VIEW_delete(projectViewl,&err);
		UF_VIEW_delete(projectViewr,&err);
		UF_VIEW_delete(baseView,&err);
		UF_VIEW_delete(IsometricView,&err);
        return 1;
    }
    else
    {
        int err = 0;
        UF_VIEW_delete(IsometricView,&err);
        Drawings::DrawingSheet *drawingSheet1= workPart->DrawingSheets()->CurrentDrawingSheet();
        Drawings::DrawingSheetBuilder *drawingSheetBuilder1;
        drawingSheetBuilder1 = workPart->DrawingSheets()->DrawingSheetBuilder(drawingSheet1);
        drawingSheetBuilder1->SetStandardMetricScale(NXOpen::Drawings::DrawingSheetBuilder::SheetStandardMetricScaleCustom);
        drawingSheetBuilder1->SetScaleNumerator(1.0);
        drawingSheetBuilder1->SetScaleDenominator(stdscale);
        NXOpen::NXObject *nXObject1;
        nXObject1 = drawingSheetBuilder1->Commit();
        drawingSheetBuilder1->Destroy();
    }
	
	if( drawingareaHei > viewHei && drawingareaLen > viewLen )
	{
		double gaph = (drawingareaHei - viewHei)/3;
		double gapl = (drawingareaLen - viewLen)/3;
		double baseview_x = 20+gapl+(xy_boud1[1]-xy_boud1[0])/2;
		double baseview_y = 40+gaph*2+(xy_boud1[3]-xy_boud1[2])/2+xy_boud2[3]-xy_boud2[2];
		double baseview_y2 = 40+gaph*2+(xy_boud1[3]-xy_boud1[2])/2+xy_boud4[3]-xy_boud4[2];
		if( baseview_y2 > baseview_y )
			baseview_y = baseview_y2;
		double projeclview_x = baseview_x;
		double projeclview_y = 40+gaph+(xy_boud2[3]-xy_boud2[2])/2;
		double projeclview_y2 = 40+gaph+(xy_boud4[3]-xy_boud4[2])/2;
		if( projeclview_y2 > projeclview_y )
			projeclview_y = projeclview_y2;
		double projecRview_x = 20+gapl*2+xy_boud1[1]-xy_boud1[0]+(xy_boud3[1]-xy_boud3[0])/2;
		double projecRview_x2 = 20+gapl*2+xy_boud1[1]-xy_boud1[0]+(xy_boud4[1]-xy_boud4[0])/2;
		if( projecRview_x2 > projecRview_x )
			projecRview_x = projecRview_x2;
		double projecRview_y = baseview_y;
		MoveBaseView(baseView,baseview_x,baseview_y );
        viewxbound[0] = baseview_x-(xy_boud1[1]-xy_boud1[0])/2;
        viewxbound[2] = baseview_y-(xy_boud1[3]-xy_boud1[2])/2;
		viewxbound[1] = baseview_x+(xy_boud1[1]-xy_boud1[0])/2;
        viewxbound[3] = baseview_y+(xy_boud1[3]-xy_boud1[2])/2;
		MoveProjectView(projectViewl,projeclview_x,projeclview_y);
		MoveProjectView(projectViewr,projecRview_x,projecRview_y);

		NXOpen::Point3d point2(projecRview_x, projeclview_y, 0.0);
		tag_t IsometricView = CreateBaseView(partTag,"Isometric", refset,point2,stdscale,sheetlen,sheethei);
		NXOpen::Session *theSession = NXOpen::Session::GetSession();
		NXOpen::Part *workPart(theSession->Parts()->Work());
		std::vector<NXOpen::Drawings::DraftingView *> views1(2);
		NXOpen::Drawings::ProjectedView *projectedView1(dynamic_cast<NXOpen::Drawings::ProjectedView *>(NXOpen::NXObjectManager::Get(projectViewl)));
		NXOpen::Drawings::ProjectedView *projectedView2(dynamic_cast<NXOpen::Drawings::ProjectedView *>(NXOpen::NXObjectManager::Get(projectViewr)));
		views1[0] = projectedView1;
		views1[1] = projectedView2;
		workPart->DraftingViews()->UpdateViews(views1);
		//ROY_UF_VIEW_ask_xy_clip(IsometricView,stdscale,xy_boud4);
		//if(stdscale<20)
        //if(projecRview_x+xy_boud4[1]>sheetLen || projecRview_x-xy_boud4[1] <  projeclview_x+(xy_boud2[1]-xy_boud2[0])/2)
        //double vlen2 = xy_boud1[1]-xy_boud1[0] + xy_boud4[1]-xy_boud4[0];
        //double vhei2 = xy_boud3[3]-xy_boud3[2] + xy_boud4[3]-xy_boud4[2];
        //if(vhei2 >= drawingareaHei || vlen2 >= drawingareaLen  ) //|| projecRview_x+xy_boud4[1]>sheetLen || projecRview_x-xy_boud4[1] <  projeclview_x+(xy_boud2[1]-xy_boud2[0])/2
        //{
        //    int err = 0;
        //    double sug1 = (vlen2-25.4)/(drawingareaLen-25.4);
        //    double sug2 = (vhei2-25.4)/(drawingareaHei-25.4);
        //    double tempsug = 0;
        //    if( sug1 > sug2 )
        //        tempsug = sug1;
        //    else
        //        tempsug = sug2;
        //    if( tempsug > sug )
        //        sug = tempsug;
        //    UF_VIEW_delete(projectViewl,&err);
        //    UF_VIEW_delete(projectViewr,&err);
        //    UF_VIEW_delete(baseView,&err);
        //    UF_VIEW_delete(IsometricView,&err);
        //    return 1;
        //}
	}
    symbolView = baseView;
	return 0;
}

static void CreateDrawingSheet(NXString& name, double len, double hei )
{
	UF_DRAW_info_t drawing_info;
	drawing_info.drawing_scale = 1.0;
	drawing_info.units = UF_PART_METRIC;
	drawing_info.projection_angle = UF_DRAW_FIRST_ANGLE_PROJECTION;
	drawing_info.size_state = UF_DRAW_METRIC_SIZE;
	tag_t new_drawing_tag = NULL_TAG;
    drawing_info.size_state = UF_DRAW_CUSTOM_SIZE;
    drawing_info.size.custom_size[0]=hei;
    drawing_info.size.custom_size[1]=len;
	UF_DRAW_create_drawing( name.GetLocaleText(), &drawing_info,&new_drawing_tag);
	UF_DRAW_open_drawing( new_drawing_tag );
}

static tag_t CreateDrawingViewDWG(tag_t part, tag_t& view, tag_t &projectViewl,tag_t &projectViewr,NXString& name,NXString& frame,NXString& typeStr,double viewbound[4],double &stdscale )
{
	UF_import_part_modes_t modes;
	tag_t group = NULL_TAG;
	tag_t new_drawing_tag = NULL_TAG;
	char titleblock[MAX_FSPEC_SIZE] = "";
	double dest_csys[6]={1,0,0,0,1,0};
	double dest_point[3]={0,0,0};
	modes.layer_mode=1;
	modes.group_mode=1;
	modes.csys_mode=0;
	modes.plist_mode=0;
	modes.view_mode=0;
	modes.cam_mode=false;
	modes.use_search_dirs=false;
	char *p_env = getenv("UGII_USER_DIR");
    double gap = 20;
    double xlengh = 0;
    double sheetlen = 0, sheethei = 0;
	if( 0 == strcmp("A3横",frame.GetLocaleText()))
	{
        /*drawing_info.size.custom_size[0]=297*scale;
		drawing_info.size.custom_size[1]=420*scale;*/
        sheetlen = 420;
        sheethei = 297;
		sprintf(titleblock,"%s\\templates\\A3.prt",p_env);
	}
	else if( 0 == strcmp("A3竖",frame.GetLocaleText()))
	{
		
		/*drawing_info.size.custom_size[0]=420*scale;
		drawing_info.size.custom_size[1]=297*scale;*/
        sheetlen = 297;
        sheethei = 420;
		sprintf(titleblock,"%s\\templates\\A3V.prt",p_env);
	}
	else //if( 0 == strcmp("A4横",frame.GetLocaleText()))
	{
		/*drawing_info.size.custom_size[0]=210*scale;
		drawing_info.size.custom_size[1]=297*scale;*/
        sheetlen = 297;
        sheethei = 210;
		sprintf(titleblock,"%s\\templates\\A4.prt",p_env);
	}

    CreateDrawingSheet( name,sheetlen,sheethei );

    UF_PART_import(titleblock,&modes,dest_csys,dest_point,1,&group);

    //int
    //    inx = 0,
    //    num_bodies = 0;
    //tag_t
    //    * body_tags = NULL,
    //    *tags = NULL;
    //char  factors[3][ UF_MAX_EXP_BUFSIZE ]={"2","2","2"};
    //double
    //    new_scale = 0.;
    //UF_GROUP_ask_group_data(group,&body_tags,&num_bodies);
    //int irc = UF_MODL_create_scale( UF_SCALE_TYPE_UNIFORM, body_tags,
    //                                   num_bodies, NULL_TAG, NULL_TAG, 
    //                                   NULL_TAG, factors,  &tags );

    //UF_MODL_create_uniform_scale
    //UF_MODL_create_scale
    //Point3d pt;
    //tag_t view = NULL_TAG;
    double sug = 0;
    //double viewbound[4]={0,0,0,0};
    /*int irc = CreateBaseAndProjectViews(part,name,stdscale,view,viewbound,sug);*/
    int irc = CreateBaseAndProjectViews(part,name,stdscale,view,projectViewl,projectViewr,viewbound,sug,sheetlen,sheethei);
    //double stdscale[] = {1.5,2,2.5,3,5,10};
    while( 0 != irc )
    {
        if(stdscale < 10.0)
            stdscale+=0.5;
        else
            stdscale+=5.0; 
        while(stdscale<sug-0.1)
        {
            if(stdscale < 10.0)
                stdscale+=0.5;
            else
                stdscale+=1.0;
        }
        irc = CreateBaseAndProjectViews(part,name,stdscale,view,projectViewl,projectViewr,viewbound,sug,sheetlen,sheethei);
    }
    //UF_PART_save();
    return group;
}

#include "Excel/Excel.h"
void autodrafting::ReadExcelTechData( )
{
	if (techData.size() > 0)
		return;

	Excel::CExcelUtil xls;
	//BasicExcel excel;
	char regfile[256]="";
	sprintf(regfile,"%s\\Parameter\\ConfigTech.xls",getenv("UGII_USER_DIR"));
    xls.SetVisible(false);
	xls.OpenExcel(regfile);
	int num = xls.GetSheetNum();

	for( int idx = 0; idx < num; ++idx )
	{
		xls.SetActiveSheet(idx+1);
		int maxRows = 32;
        StlNXStringVector sheetData;
        for(int j = 1; j < maxRows; ++j)
        {
            CString str = xls.GetCellValue(j,1).GetBuffer();
            if (str.GetLength() > 0)
            {
                sheetData.push_back(WCHARTOCHAR(str.GetBuffer()));
            }
        }
        techData.push_back(sheetData);
	}
	xls.CloseExcel();
	return;
}
//------------------------------------------------------------------------------
//Callback Name: apply_cb
//------------------------------------------------------------------------------
#if 0
int autodrafting::apply_cb()
{
    int errorCode = 0;
    try
    {
        //---- Enter your callback code here -----
		std::vector<Node*> SelectedNodes;
		NXOpen::BlockStyler::Node * treeNode = tree_control0->RootNode();
		while( NULL != treeNode )
		{
			SelectedNodes.push_back(treeNode);
			treeNode = treeNode->NextNode();
		}
        for( int idx = 0; idx < SelectedNodes.size(); ++idx )
        {
            NXOpen::DataContainer *nodeData = SelectedNodes[idx]->GetNodeData();
            std::vector<NXOpen::TaggedObject *>objects = nodeData->GetTaggedObjectVector("Data");
            if( objects.size() > 0 )
            {
				StlTagVector bodies;
				bodies.push_back(objects[0]->Tag());
				NXString name = SelectedNodes[idx]->GetColumnDisplayText(0);
				CreateReferenceSet(bodies,name);
            }
        }
		tag_t disp = UF_PART_ask_display_part();
		tag_t newpart = CreateDWGPart();
		if( NULL_TAG != newpart )
		{
			for( int idx = 0; idx < SelectedNodes.size(); ++idx )
			{
				NXOpen::DataContainer *nodeData = SelectedNodes[idx]->GetNodeData();
				std::vector<NXOpen::TaggedObject *>objects = nodeData->GetTaggedObjectVector("Data");
				if( objects.size() > 0 )
				{
					NXString name = SelectedNodes[idx]->GetColumnDisplayText(0);
					NXString frame = SelectedNodes[idx]->GetColumnDisplayText(1);
					NXString scale = SelectedNodes[idx]->GetColumnDisplayText(2);
					CreateDrawingViewDWG(name,frame,scale);
				}
			}
			UF_PART_save();
			UF_PART_close(newpart,0,1);
			theSession->ApplicationSwitchImmediate("UG_APP_MODELING");
		}
		UF_PART_set_display_part(disp);
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        autodrafting::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}
#endif

void autodrafting::SetTypeUI()
{
    char attriValue2[133]="";
    std::vector<NXString> typestrs = enumType->GetEnumMembers();
    int sel = 0;
    UI_EnumGetCurrentSel(enumType, sel);
    NXString typeStr = typestrs[sel];
    sprintf(attriValue2,"%s加工图",typeStr.GetLocaleText());
    drawingName->GetProperties()->SetString("Value",attriValue2);
    ReadExcelTechData();
    StlNXStringVector tech = techData[sel];
    //StlNXStringVector tech;
	//tech.push_back("get test");
    multiline_string0->SetValue(tech);
}

void autodrafting::AddBodyInformation( )
{
    logical newbody = true;
    NXString drawingNum = drawingNO->GetProperties()->GetString("Value");
    for( int idx = 0; idx < BodiesDefined.size(); ++idx )
    {
        DrawingBody t = BodiesDefined[idx];
        if(0 == strcmp(t.DrawingNO.GetLocaleText(),drawingNum.GetLocaleText()))
        {
            std::vector<NXString> typestrs = enumType->GetEnumMembers();
            int sel = 0;
            UI_EnumGetCurrentSel(enumType, sel);
            NXString typeStr = typestrs[sel];
            BodiesDefined[idx].DrawingName = drawingName->GetProperties()->GetString("Value");
            BodiesDefined[idx].type = typeStr;
            BodiesDefined[idx].tech = multiline_string0->GetValue();
            newbody = false;
            break;
        }
    }
    if(newbody)
    {
        DrawingBody temp;
        std::vector<NXString> typestrs = enumType->GetEnumMembers();
        int sel = 0;
        UI_EnumGetCurrentSel(enumType, sel);
        NXString typeStr = typestrs[sel];
        temp.DrawingName = drawingName->GetProperties()->GetString("Value");
        temp.type = typeStr;
        temp.tech = multiline_string0->GetValue();
        temp.DrawingNO = drawingNO->GetProperties()->GetString("Value");
        BodiesDefined.push_back(temp);
    }
}

int autodrafting::ValidateDrawingNO()
{
    int irc = 0;
    NXString drawingNum = drawingNO->GetProperties()->GetString("Value");
    NXOpen::BlockStyler::Node * treeNode = tree_control0->RootNode();
    while( NULL != treeNode )
    {
        //SelectedNodes.push_back(treeNode);
        NXString nodName = treeNode->GetColumnDisplayText(0);
        if( 0 == strcmp(nodName.GetLocaleText(),drawingNum.GetLocaleText()))
        {
            irc = 1;
            break;
        }
        treeNode = treeNode->NextNode();
    }
    return irc ;
}
//------------------------------------------------------------------------------
//Callback Name: update_cb
//------------------------------------------------------------------------------
int autodrafting::update_cb(NXOpen::BlockStyler::UIBlock* block)
{
    try
    {
        if(block == enumType)
        {
            //---------Enter your code here-----------
            SetTypeUI();
        }
        else if(block == bodySelect0)
        {
        //---------Enter your code here-----------
            char attriValue2[133] = "";
            std::vector<NXOpen::TaggedObject* > objects = bodySelect0->GetProperties()->GetTaggedObjectVector("SelectedObjects");
            if(objects.size() > 0 )
            {
                USER_ask_obj_string_attr( objects[0]->Tag() , "材料编号" , attriValue2 );
                drawingNO->GetProperties()->SetString("Value",attriValue2);

				//------处理材料类型-----
				USER_ask_obj_string_attr(objects[0]->Tag(), "材料类型", attriValue2);
				std::vector<NXString> typestrs = enumType->GetEnumMembers();
				for (int kk = 0; kk < typestrs.size(); kk++)
				{
					if (strcmp(typestrs[kk].getLocaleText(),attriValue2) == 0)
					{
						UI_EnumSetCurrentSel(enumType, kk);
						SetTypeUI(); 
						break;
					}
				}
				
				//-----材料类型处理结束-----

                buttonApplyCSYS->GetProperties()->SetLogical("Enable",true);
            }
            else
                buttonApplyCSYS->GetProperties()->SetLogical("Enable",false);
        }
        else if(block == toggleHide)
        {
            logical hide = toggleHide->GetProperties()->GetLogical("Value");
            std::vector<Node*> SelectedNodes = tree_control0->GetSelectedNodes();
            for( int idx = 0; idx < SelectedNodes.size(); ++idx )
            {
                NXOpen::DataContainer *nodeData = SelectedNodes[idx]->GetNodeData();
                std::vector<NXOpen::TaggedObject *>objects = nodeData->GetTaggedObjectVector("Data");
                for(int jdx = 0; jdx < objects.size(); ++jdx )
                {
                    UF_OBJ_set_blank_status(objects[jdx]->Tag(),hide);
                }
                if(hide)
                    SelectedNodes[idx]->SetColumnDisplayText( 2, "隐藏" );
                else
                    SelectedNodes[idx]->SetColumnDisplayText( 2, "显示" );
            }
        }
        else if(block == multiline_string0)
        {
        //---------Enter your code here-----------
        }
        else if(block == coord_system0)
        {
        //---------Enter your code here-----------
        }
        else if(block == buttonDelete)
        {
            std::vector<Node*> SelectedNodes = tree_control0->GetSelectedNodes();
            for( int idx = 0; idx < SelectedNodes.size(); ++idx )
            {
                tree_control0->DeleteNode(SelectedNodes[idx]);
            }
        }
        else if(block == buttonApplyCSYS)
        {
        //---------Enter your code here-----------
			Point3d originPoint;
			double org[3] = {0.0,0,0}, csys[6] = {1,0,0,0,1,0};
            NXString drawingNum = drawingNO->GetProperties()->GetString("Value");
            if( strlen(drawingNum.GetLocaleText()) < 1 )
            {
                uc1601("请输入图号",1);
                return 1;
            }
            int irc = ValidateDrawingNO();
            if( irc == 1 )
            {
                uc1601("图号已经存在",1);
                return 1;
            }
            AddBodyInformation();
            NXString frame = enumFrameType->GetProperties()->GetEnumAsString("Value");
            logical hidebody = toggleHide->GetProperties()->GetLogical("Value");
            std::vector<NXOpen::TaggedObject* > objects = bodySelect0->GetProperties()->GetTaggedObjectVector("SelectedObjects");
			std::vector<NXOpen::TaggedObject* > csysObjects = coord_system0->GetProperties()->GetTaggedObjectVector("SelectedObjects");
			if( csysObjects.size() > 0 )
			{
				tag_t csys_tag = csysObjects[0]->Tag();
				NXOpen::CoordinateSystem *coord_system = (NXOpen::CoordinateSystem *)NXOpen::NXObjectManager::Get(csys_tag);
				originPoint =  coord_system->Origin(); 
				NXOpen::NXMatrix *matrix = coord_system->Orientation();
				Matrix3x3 matrix33 = matrix->Element();
				csys[0] = matrix33.Xx;
				csys[1] = matrix33.Xy;
				csys[2] = matrix33.Xz;
				csys[3] = matrix33.Zx;
				csys[4] = matrix33.Zy;
				csys[5] = matrix33.Zz;
                for( int idx = 0; idx < objects.size(); ++idx )
                {
                    char str[133]="";
                    tag_t body =objects[idx]->Tag();
                    sprintf(str,"%g",csys[0]);
                    Royal_set_obj_attr(body,ATTR_DRAFTING_X_DIR_X,str);
                    sprintf(str,"%g",csys[1]);
                    Royal_set_obj_attr(body,ATTR_DRAFTING_X_DIR_Y,str);
                    sprintf(str,"%g",csys[2]);
                    Royal_set_obj_attr(body,ATTR_DRAFTING_X_DIR_Z,str);
                    sprintf(str,"%g",csys[3]);
                    Royal_set_obj_attr(body,ATTR_DRAFTING_NORMAL_DIR_X,str);
                    sprintf(str,"%g",csys[4]);
                    Royal_set_obj_attr(body,ATTR_DRAFTING_NORMAL_DIR_Y,str);
                    sprintf(str,"%g",csys[5]);
                    Royal_set_obj_attr(body,ATTR_DRAFTING_NORMAL_DIR_Z,str);
                }
			}
            BlockStyler::Node* node = tree_control0->CreateNode(drawingNum);
            NXOpen::DataContainer *nodeData = node->GetNodeData();
            nodeData->AddTaggedObjectVector("Data",objects);
            tree_control0->InsertNode(node, NULL, NULL, Tree::NodeInsertOptionLast);
            node->SetColumnDisplayText( 1, frame );
            if(hidebody)
            {
                node->SetColumnDisplayText( 2, "隐藏" );
                for( int idx = 0; idx < objects.size(); ++idx )
                {
                    UF_OBJ_set_blank_status(objects[idx]->Tag(),UF_OBJ_BLANKED);
                }
            }
            else
            {
                node->SetColumnDisplayText( 2, "显示" );
            }
            
            std::vector<NXOpen::TaggedObject* > objectsNull;
            std::vector<NXOpen::TaggedObject* > csysObjectsNull;
            bodySelect0->GetProperties()->SetTaggedObjectVector("SelectedObjects",objectsNull);
            //coord_system0->GetProperties()->SetTaggedObjectVector("SelectedObjects",objectsNull);
            //for( int idx = 0; idx < bodies.size(); ++idx )
            //{
            //    // 名称
            //    char temStr[MAX_FSPEC_SIZE] = "";
            //    sprintf( temStr, "零件%02d",  nodeCount );
            //    UF_ATTR_value_t attr_spec_name;
            //    std::vector<NXOpen::TaggedObject *>objects;
            //    BlockStyler::Node* node = tree_control0->CreateNode(temStr);
            //    nodeCount++;
            //    objects.push_back( ( NXOpen::TaggedObject *)NXOpen::NXObjectManager::Get(bodies[idx]) );
            //    NXOpen::DataContainer *nodeData = node->GetNodeData();
            //    nodeData->AddTaggedObjectVector("Data",objects);
            //    tree_control0->InsertNode(node, NULL, NULL, Tree::NodeInsertOptionLast);
            //    for( int kdx = 0; kdx < ColumnNames.size(); ++kdx )
            //    {
            //        if( 0 == strcmp("图纸", ColumnNames[kdx].GetLocaleText() ) )
            //        {
            //            node->SetColumnDisplayText( kdx, NXString("A4横", NXString::Locale) );
            //        }
            //        else if( 0 == strcmp("比例", ColumnNames[kdx].GetLocaleText() ) )
            //        {
            //            node->SetColumnDisplayText( kdx, NXString("1.0", NXString::Locale) );
            //        }
            //    }
            //}

			//std::vector<Node*> SelectedNodes = tree_control0->GetSelectedNodes();
			
        }
        else if(block == enumFrameType)
        {
        //---------Enter your code here-----------
            std::vector<Node*> nodes = tree_control0->GetSelectedNodes();
            NXString frame = enumFrameType->GetProperties()->GetEnumAsString("Value");
            for(int idx = 0; idx < nodes.size();++idx )
            {
                nodes[idx]->SetColumnDisplayText(1,frame);
            }
        }
        else if(block == drawingNO)
        {
        //---------Enter your code here-----------
            std::vector<Node*> nodes = tree_control0->GetSelectedNodes();
            NXString draNO = drawingNO->GetProperties()->GetString("Value");
            for(int idx = 0; idx < nodes.size();++idx )
            {
                nodes[idx]->SetColumnDisplayText(0,draNO);
            }
        }
        else if(block == doubleDwgScale)
        {
        //---------Enter your code here-----------
            /*std::vector<Node*> nodes = tree_control0->GetSelectedNodes();
            double scale = doubleDwgScale->GetProperties()->GetDouble("Value");
            char str[133]="";
            sprintf(str,"%.01f",scale);
            for(int idx = 0; idx < nodes.size();++idx )
            {
                nodes[idx]->SetColumnDisplayText(2,str);
            }*/
        }
        else if(block == nativeFolderBrowser01)
        {
        //---------Enter your code here-----------
        }
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        autodrafting::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}

tag_t GetMinDistanceObject( double pt[3], StlTagVector& objects )
{
	tag_t target = NULL_TAG;
	tag_t planeTag = NULL_TAG;
	NXOpen::Session *theSession = NXOpen::Session::GetSession();
    NXOpen::Part *workPart(theSession->Parts()->Work());
	if (objects.size() > 0 )
	{
		target = objects[0];
		NXOpen::Point *point1;
		NXOpen::Point3d coordinates1(pt[0], pt[1], pt[2]);
		//double dir[3]={0,1,0};
		point1 = workPart->Points()->CreatePoint(coordinates1);
		//UF_MODL_create_plane(pt,dir,&planeTag);
		double mindist = 0;
		CF_AskMinimumDist(point1->Tag(),target,mindist);
		for( int idx = 1; idx < objects.size(); ++idx )
		{
			double tempdis = 0;
			CF_AskMinimumDist(point1->Tag(),objects[idx],tempdis);
			if( MATH_is_less2(tempdis , mindist,DOUBLE_TOL))
			{
				mindist = tempdis;
				target = objects[idx];
			}
		}
		UF_OBJ_delete_object(point1->Tag());
	}
	return target;
}
void CreateDemension2(tag_t partTag, tag_t viewTag, StlTagVector& objects, int flag, double bound[4])
{
	NXOpen::Session *theSession = NXOpen::Session::GetSession();
    NXOpen::Part *workPart(theSession->Parts()->Work());
	NXOpen::Part *dispPart(theSession->Parts()->Display());
	double offset = 1000;
	tag_t firstTag = NULL_TAG, secondTag = NULL_TAG;
	double leftpt2d[2]={bound[0]-offset,(bound[2]+bound[3])/2};
	double rightpt2d[2]={bound[1]+offset,(bound[2]+bound[3])/2};
	double bottompt2d[2]={(bound[0]+bound[1])/2,bound[2]-offset};
	double toppt2d[2]={(bound[0]+bound[1])/2,bound[3]+offset};
	double firstPoint[3], secondPoint[3];
	//UF_ASSEM_set_work_part(partTag);
	//UF_PART_set_display_part(partTag);
	if( 0 == flag )
	{
		UF_VIEW_map_drawing_to_model(viewTag,toppt2d,firstPoint);
		UF_VIEW_map_drawing_to_model(viewTag,bottompt2d,secondPoint);
	}
	else
	{
		UF_VIEW_map_drawing_to_model(viewTag,rightpt2d,firstPoint);
		UF_VIEW_map_drawing_to_model(viewTag,leftpt2d,secondPoint);
	}
	firstTag = GetMinDistanceObject(firstPoint,objects);
	secondTag = GetMinDistanceObject(secondPoint,objects);
	//UF_ASSEM_set_work_part(workPart->Tag());
	//UF_PART_set_display_part(dispPart->Tag());

    NXOpen::Annotations::Dimension *nullNXOpen_Annotations_Dimension(NULL);
    NXOpen::Annotations::RapidDimensionBuilder *rapidDimensionBuilder1;
    rapidDimensionBuilder1 = workPart->Dimensions()->CreateRapidDimensionBuilder(nullNXOpen_Annotations_Dimension);
    
    rapidDimensionBuilder1->Origin()->SetInferRelativeToGeometry(true);
  
    rapidDimensionBuilder1->Origin()->Plane()->SetPlaneMethod(NXOpen::Annotations::PlaneBuilder::PlaneMethodTypeXyPlane);
    
    NXOpen::Direction *nullNXOpen_Direction(NULL);
    rapidDimensionBuilder1->Measurement()->SetDirection(nullNXOpen_Direction);
    
    NXOpen::View *nullNXOpen_View(NULL);
    rapidDimensionBuilder1->Measurement()->SetDirectionView(nullNXOpen_View);
    
    rapidDimensionBuilder1->Style()->DimensionStyle()->SetNarrowDisplayType(NXOpen::Annotations::NarrowDisplayOptionNone);

	NXOpen::Drawings::BaseView *baseView1(dynamic_cast<Drawings::BaseView *>(NXOpen::NXObjectManager::Get(viewTag)));
    NXOpen::Drawings::DraftingCurve *draftingCurve1(dynamic_cast<NXOpen::Drawings::DraftingCurve *>(NXOpen::NXObjectManager::Get(firstTag)));
	int type = 0, subtype = 0;
	int type2 = 0, subtype2 = 0;
	double ref[3]={0,0,0};
	double pt2d[2],pt3d[3];
	UF_OBJ_ask_type_and_subtype(firstTag, &type, &subtype);
	UF_OBJ_ask_type_and_subtype(secondTag, &type2, &subtype2);
    //NXOpen::Point3d point1_1(-0.490001264002843, 100, 0.0);
    //NXOpen::Point3d point1_1(boundbox1[3], boundbox1[4], boundbox1[5]);
    NXOpen::Point3d point1_1(firstPoint[0], firstPoint[1], firstPoint[2]);
    NXOpen::Point3d point2_1(0.0, 0.0, 0.0);
    //rapidDimensionBuilder1->FirstAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeDrfTangent, draftingCurve1, baseView1, point1_1, NULL, nullNXOpen_View, point2_1);
    if(type == UF_circle_type|| type == UF_conic_type)
	{
		rapidDimensionBuilder1->FirstAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeDrfTangent, draftingCurve1, baseView1, point1_1, NULL, nullNXOpen_View, point2_1);
	}
	else //if(type == UF_line_type)
	{
		rapidDimensionBuilder1->FirstAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeEnd, draftingCurve1, baseView1, point1_1, NULL, nullNXOpen_View, point2_1);
	}
    NXOpen::Drawings::DraftingCurve *draftingCurve2(dynamic_cast<NXOpen::Drawings::DraftingCurve *>(NXOpen::NXObjectManager::Get(secondTag)));
    //NXOpen::Point3d point1_2(-22.0000000000002, -26.9999999999995, -129.357884749828);
	
	//NXOpen::Point3d point1_2(-0.490001264002843, 100, 0.0);
    NXOpen::Point3d point2_2(0.0, 0.0, 0.0);
	

	NXOpen::Point3d point1_2(secondPoint[0], secondPoint[1], secondPoint[2]);
    //rapidDimensionBuilder1->SecondAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeEnd, draftingCurve2, baseView1, point1_2, NULL, nullNXOpen_View, point2_2);
    if(type2 == UF_circle_type|| type2 == UF_conic_type)
	{
		rapidDimensionBuilder1->SecondAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeDrfTangent, draftingCurve2, baseView1, point1_2, NULL, nullNXOpen_View, point2_2);
	}
	else //if(type == UF_line_type)
	{
		rapidDimensionBuilder1->SecondAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeStart, draftingCurve2, baseView1, point1_2, NULL, nullNXOpen_View, point2_2);
	}

    NXOpen::Annotations::Annotation::AssociativeOriginData assocOrigin1;
    assocOrigin1.OriginType = NXOpen::Annotations::AssociativeOriginTypeDrag;
    assocOrigin1.View = nullNXOpen_View;
    assocOrigin1.ViewOfGeometry = nullNXOpen_View;
    NXOpen::Point *nullNXOpen_Point(NULL);
    assocOrigin1.PointOnGeometry = nullNXOpen_Point;
    NXOpen::Annotations::Annotation *nullNXOpen_Annotations_Annotation(NULL);
    assocOrigin1.VertAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.VertAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.HorizAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.HorizAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.AlignedAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.DimensionLine = 0;
    assocOrigin1.AssociatedView = nullNXOpen_View;
    assocOrigin1.AssociatedPoint = nullNXOpen_Point;
    assocOrigin1.OffsetAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.OffsetAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.XOffsetFactor = 0.0;
    assocOrigin1.YOffsetFactor = 0.0;
    assocOrigin1.StackAlignmentPosition = NXOpen::Annotations::StackAlignmentPositionAbove;
    rapidDimensionBuilder1->Origin()->SetAssociativeOrigin(assocOrigin1);
    
	NXOpen::Point3d point1(bound[0]-5, (bound[3]+bound[1])/2, 0.0);
	rapidDimensionBuilder1->Style()->LineArrowStyle()->SetLeaderOrientation(NXOpen::Annotations::LeaderSideLeft);
	if( 1 == flag )
	{
		point1.X = (bound[2]+bound[0])/2;
		point1.Y = bound[3]+5;
		rapidDimensionBuilder1->Style()->LineArrowStyle()->SetLeaderOrientation(NXOpen::Annotations::LeaderSideRight);
		rapidDimensionBuilder1->Measurement()->SetMethod(NXOpen::Annotations::DimensionMeasurementBuilder::MeasurementMethodHorizontal);
	}
	else
	{
		//rapidDimensionBuilder1->Measurement()->SetMethod(NXOpen::Annotations::DimensionMeasurementBuilder::MeasurementMethodVertical);
	}
    
    rapidDimensionBuilder1->Origin()->Origin()->SetValue(NULL, nullNXOpen_View, point1);
    
    rapidDimensionBuilder1->Origin()->SetInferRelativeToGeometry(true);

    NXOpen::NXObject *nXObject1;
    nXObject1 = rapidDimensionBuilder1->Commit();
    
    rapidDimensionBuilder1->Destroy(); 

}

void CreateDemension3(tag_t partTag, tag_t viewTag, StlTagVector& objects, int flag, double firstPoint[3], double secondPoint[3],double scale )
{
	NXOpen::Session *theSession = NXOpen::Session::GetSession();
    NXOpen::Part *workPart(theSession->Parts()->Work());
	NXOpen::Part *dispPart(theSession->Parts()->Display());
	double offset = 1000;
	tag_t firstTag = NULL_TAG, secondTag = NULL_TAG;

	firstTag = GetMinDistanceObject(firstPoint,objects);
	secondTag = GetMinDistanceObject(secondPoint,objects);
	//UF_ASSEM_set_work_part(workPart->Tag());
	//UF_PART_set_display_part(dispPart->Tag());
    NXOpen::Annotations::Dimension *nullNXOpen_Annotations_Dimension(NULL);
    NXOpen::Annotations::RapidDimensionBuilder *rapidDimensionBuilder1;
    rapidDimensionBuilder1 = workPart->Dimensions()->CreateRapidDimensionBuilder(nullNXOpen_Annotations_Dimension);
    
    rapidDimensionBuilder1->Origin()->SetInferRelativeToGeometry(true);
  
    rapidDimensionBuilder1->Origin()->Plane()->SetPlaneMethod(NXOpen::Annotations::PlaneBuilder::PlaneMethodTypeXyPlane);
    
    NXOpen::Direction *nullNXOpen_Direction(NULL);
    rapidDimensionBuilder1->Measurement()->SetDirection(nullNXOpen_Direction);
    
    NXOpen::View *nullNXOpen_View(NULL);
    rapidDimensionBuilder1->Measurement()->SetDirectionView(nullNXOpen_View);
    
    rapidDimensionBuilder1->Style()->DimensionStyle()->SetNarrowDisplayType(NXOpen::Annotations::NarrowDisplayOptionNone);

	//NXOpen::Drawings::BaseView *baseView1(dynamic_cast<Drawings::BaseView *>(NXOpen::NXObjectManager::Get(viewTag)));
	NXOpen::View *baseView1(dynamic_cast<NXOpen::View *>(NXOpen::NXObjectManager::Get(viewTag)));
	//NXOpen::Drawings::ProjectedView *projectedView1(dynamic_cast<NXOpen::Drawings::ProjectedView *>(workPart->DraftingViews()->FindObject("ORTHO@8")));
	
    NXOpen::Drawings::DraftingCurve *draftingCurve1(dynamic_cast<NXOpen::Drawings::DraftingCurve *>(NXOpen::NXObjectManager::Get(firstTag)));
	int type = 0, subtype = 0;
	int type2 = 0, subtype2 = 0;
	double ref[3]={0,0,0};
	double pt2d[2],pt3d[3];
	UF_OBJ_ask_type_and_subtype(firstTag, &type, &subtype);
	UF_OBJ_ask_type_and_subtype(secondTag, &type2, &subtype2);
    //NXOpen::Point3d point1_1(-0.490001264002843, 100, 0.0);
    //NXOpen::Point3d point1_1(boundbox1[3], boundbox1[4], boundbox1[5]);
    NXOpen::Point3d point1_1(firstPoint[0], firstPoint[1], firstPoint[2]);
    NXOpen::Point3d point2_1(0.0, 0.0, 0.0);
    //rapidDimensionBuilder1->FirstAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeDrfTangent, draftingCurve1, baseView1, point1_1, NULL, nullNXOpen_View, point2_1);
    if(type == UF_circle_type|| type == UF_conic_type)
	{
		rapidDimensionBuilder1->FirstAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeDrfTangent, draftingCurve1, baseView1, point1_1, NULL, nullNXOpen_View, point2_1);
	}
	else //if(type == UF_line_type)
	{
		rapidDimensionBuilder1->FirstAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeEnd, draftingCurve1, baseView1, point1_1, NULL, nullNXOpen_View, point2_1);
	}
    NXOpen::Drawings::DraftingCurve *draftingCurve2(dynamic_cast<NXOpen::Drawings::DraftingCurve *>(NXOpen::NXObjectManager::Get(secondTag)));
    //NXOpen::Point3d point1_2(-22.0000000000002, -26.9999999999995, -129.357884749828);
	
	//NXOpen::Point3d point1_2(-0.490001264002843, 100, 0.0);
    NXOpen::Point3d point2_2(0.0, 0.0, 0.0);
	

	NXOpen::Point3d point1_2(secondPoint[0], secondPoint[1], secondPoint[2]);
    //rapidDimensionBuilder1->SecondAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeEnd, draftingCurve2, baseView1, point1_2, NULL, nullNXOpen_View, point2_2);
    if(type2 == UF_circle_type|| type2 == UF_conic_type)
	{
		rapidDimensionBuilder1->SecondAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeDrfTangent, draftingCurve2, baseView1, point1_2, NULL, nullNXOpen_View, point2_2);
	}
	else //if(type == UF_line_type)
	{
		rapidDimensionBuilder1->SecondAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeStart, draftingCurve2, baseView1, point1_2, NULL, nullNXOpen_View, point2_2);
	}

    NXOpen::Annotations::Annotation::AssociativeOriginData assocOrigin1;
    assocOrigin1.OriginType = NXOpen::Annotations::AssociativeOriginTypeDrag;
    assocOrigin1.View = nullNXOpen_View;
    assocOrigin1.ViewOfGeometry = nullNXOpen_View;
    NXOpen::Point *nullNXOpen_Point(NULL);
    assocOrigin1.PointOnGeometry = nullNXOpen_Point;
    NXOpen::Annotations::Annotation *nullNXOpen_Annotations_Annotation(NULL);
    assocOrigin1.VertAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.VertAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.HorizAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.HorizAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.AlignedAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.DimensionLine = 0;
    assocOrigin1.AssociatedView = nullNXOpen_View;
    assocOrigin1.AssociatedPoint = nullNXOpen_Point;
    assocOrigin1.OffsetAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.OffsetAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.XOffsetFactor = 0.0;
    assocOrigin1.YOffsetFactor = 0.0;
    assocOrigin1.StackAlignmentPosition = NXOpen::Annotations::StackAlignmentPositionAbove;
    rapidDimensionBuilder1->Origin()->SetAssociativeOrigin(assocOrigin1);
	double viewbound[4] = {0};
	double viewcenter[3] = {0};
	ROY_UF_VIEW_ask_xy_clip(viewTag,scale,viewbound);
	UF_VIEW_ask_center(viewTag,viewcenter);
	UF_VIEW_map_model_to_drawing(viewTag,viewcenter,pt2d);
	viewbound[0] += pt2d[0];
	viewbound[1] += pt2d[0];
	viewbound[2] += pt2d[1];
	viewbound[3] += pt2d[1];
	NXOpen::Point3d point1(viewbound[0]-5, (viewbound[3]+viewbound[2])/2, 0.0);
	rapidDimensionBuilder1->Style()->LineArrowStyle()->SetLeaderOrientation(NXOpen::Annotations::LeaderSideLeft);
	if( 1 == flag )
	{
		point1.X = (viewbound[1]+viewbound[0])/2;
		point1.Y = viewbound[3]+5;
		rapidDimensionBuilder1->Style()->LineArrowStyle()->SetLeaderOrientation(NXOpen::Annotations::LeaderSideRight);
		rapidDimensionBuilder1->Measurement()->SetMethod(NXOpen::Annotations::DimensionMeasurementBuilder::MeasurementMethodHorizontal);
	}
	else
	{
		//rapidDimensionBuilder1->Measurement()->SetMethod(NXOpen::Annotations::DimensionMeasurementBuilder::MeasurementMethodVertical);
	}
    
    rapidDimensionBuilder1->Origin()->Origin()->SetValue(NULL, nullNXOpen_View, point1);
    
    rapidDimensionBuilder1->Origin()->SetInferRelativeToGeometry(true);

    NXOpen::NXObject *nXObject1;
    nXObject1 = rapidDimensionBuilder1->Commit();
    
    rapidDimensionBuilder1->Destroy(); 

}
void CreateDemension( tag_t viewTag, tag_t firstTag, tag_t secondTag, int flag, double bound[4])
{
	NXOpen::Session *theSession = NXOpen::Session::GetSession();
    NXOpen::Part *workPart(theSession->Parts()->Work());

    
    NXOpen::Annotations::Dimension *nullNXOpen_Annotations_Dimension(NULL);
    NXOpen::Annotations::RapidDimensionBuilder *rapidDimensionBuilder1;
    rapidDimensionBuilder1 = workPart->Dimensions()->CreateRapidDimensionBuilder(nullNXOpen_Annotations_Dimension);
    
    rapidDimensionBuilder1->Origin()->SetInferRelativeToGeometry(true);
  
    rapidDimensionBuilder1->Origin()->Plane()->SetPlaneMethod(NXOpen::Annotations::PlaneBuilder::PlaneMethodTypeXyPlane);
    
    NXOpen::Direction *nullNXOpen_Direction(NULL);
    rapidDimensionBuilder1->Measurement()->SetDirection(nullNXOpen_Direction);
    
    NXOpen::View *nullNXOpen_View(NULL);
    rapidDimensionBuilder1->Measurement()->SetDirectionView(nullNXOpen_View);
    
    rapidDimensionBuilder1->Style()->DimensionStyle()->SetNarrowDisplayType(NXOpen::Annotations::NarrowDisplayOptionNone);

	NXOpen::Drawings::BaseView *baseView1(dynamic_cast<Drawings::BaseView *>(NXOpen::NXObjectManager::Get(viewTag)));
    NXOpen::Drawings::DraftingCurve *draftingCurve1(dynamic_cast<NXOpen::Drawings::DraftingCurve *>(NXOpen::NXObjectManager::Get(firstTag)));
	int type = 0, subtype = 0;
	int type2 = 0, subtype2 = 0;
	double ref[3]={0,0,0};
	double boundbox1[6]={0};
	double boundbox2[6]={0};
	double pt2d[2],pt3d[3];
	UF_OBJ_ask_type_and_subtype(firstTag, &type, &subtype);
	UF_OBJ_ask_type_and_subtype(secondTag, &type2, &subtype2);
	UF_MODL_ask_bounding_box(firstTag,boundbox1);
	UF_MODL_ask_bounding_box(secondTag,boundbox2);

	UF_VIEW_map_model_to_drawing(viewTag,boundbox1+3,pt2d);
	if( 0 == flag ) // top 
	{
		pt2d[1] += 999999;
	}
	else//right
	{
		pt2d[0] += 999999;
	}
	UF_VIEW_map_drawing_to_model(viewTag,pt2d,pt3d);
    //NXOpen::Point3d point1_1(-0.490001264002843, 100, 0.0);
    //NXOpen::Point3d point1_1(boundbox1[3], boundbox1[4], boundbox1[5]);
    NXOpen::Point3d point1_1(pt3d[0], pt3d[1], pt3d[2]);
    NXOpen::Point3d point2_1(0.0, 0.0, 0.0);
    //rapidDimensionBuilder1->FirstAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeDrfTangent, draftingCurve1, baseView1, point1_1, NULL, nullNXOpen_View, point2_1);
    if(type == UF_circle_type|| type == UF_conic_type)
	{
		rapidDimensionBuilder1->FirstAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeDrfTangent, draftingCurve1, baseView1, point1_1, NULL, nullNXOpen_View, point2_1);
	}
	else //if(type == UF_line_type)
	{
		rapidDimensionBuilder1->FirstAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeEnd, draftingCurve1, baseView1, point1_1, NULL, nullNXOpen_View, point2_1);
	}
    NXOpen::Drawings::DraftingCurve *draftingCurve2(dynamic_cast<NXOpen::Drawings::DraftingCurve *>(NXOpen::NXObjectManager::Get(secondTag)));
    //NXOpen::Point3d point1_2(-22.0000000000002, -26.9999999999995, -129.357884749828);
	
	//NXOpen::Point3d point1_2(-0.490001264002843, 100, 0.0);
    NXOpen::Point3d point2_2(0.0, 0.0, 0.0);
	
	UF_VIEW_map_model_to_drawing(viewTag,boundbox2,pt2d);
	if( 0 == flag ) // bottom
	{
		pt2d[1] -= 999999;
	}
	else //left
	{
		pt2d[0] -= 999999;
	}
	UF_VIEW_map_drawing_to_model(viewTag,pt2d,pt3d);
	NXOpen::Point3d point1_2(pt3d[0], pt3d[1], pt3d[2]);
    //rapidDimensionBuilder1->SecondAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeEnd, draftingCurve2, baseView1, point1_2, NULL, nullNXOpen_View, point2_2);
    if(type2 == UF_circle_type|| type2 == UF_conic_type)
	{
		rapidDimensionBuilder1->SecondAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeDrfTangent, draftingCurve2, baseView1, point1_2, NULL, nullNXOpen_View, point2_2);
	}
	else //if(type == UF_line_type)
	{
		int cnt = 0;
		double *pts, parm=0;
		double pt1[2]={0,0},pt2[2]={0,0};
		//UF_MODL_ask_curve_parm(secondTag,ref,&parm,pts);
		double end[3],start[3];
		tag_t edge = NULL_TAG;
		/*UF_CALL(UF_MODL_create_curve_from_edge(secondTag, &edge));
		UF_CALL(UF_MODL_ask_edge_verts(edge, start, end, &cnt));
		UF_VIEW_map_model_to_drawing(viewTag,start,pt1);
		UF_VIEW_map_model_to_drawing(viewTag,end,pt2);*/
		rapidDimensionBuilder1->SecondAssociativity()->SetValue(NXOpen::InferSnapType::SnapTypeStart, draftingCurve2, baseView1, point1_2, NULL, nullNXOpen_View, point2_2);
	}

    NXOpen::Annotations::Annotation::AssociativeOriginData assocOrigin1;
    assocOrigin1.OriginType = NXOpen::Annotations::AssociativeOriginTypeDrag;
    assocOrigin1.View = nullNXOpen_View;
    assocOrigin1.ViewOfGeometry = nullNXOpen_View;
    NXOpen::Point *nullNXOpen_Point(NULL);
    assocOrigin1.PointOnGeometry = nullNXOpen_Point;
    NXOpen::Annotations::Annotation *nullNXOpen_Annotations_Annotation(NULL);
    assocOrigin1.VertAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.VertAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.HorizAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.HorizAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.AlignedAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.DimensionLine = 0;
    assocOrigin1.AssociatedView = nullNXOpen_View;
    assocOrigin1.AssociatedPoint = nullNXOpen_Point;
    assocOrigin1.OffsetAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.OffsetAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.XOffsetFactor = 0.0;
    assocOrigin1.YOffsetFactor = 0.0;
    assocOrigin1.StackAlignmentPosition = NXOpen::Annotations::StackAlignmentPositionAbove;
    rapidDimensionBuilder1->Origin()->SetAssociativeOrigin(assocOrigin1);
    
	NXOpen::Point3d point1(bound[0]-5, (bound[3]+bound[1])/2, 0.0);
	rapidDimensionBuilder1->Style()->LineArrowStyle()->SetLeaderOrientation(NXOpen::Annotations::LeaderSideLeft);
	if( 1 == flag )
	{
		point1.X = (bound[2]+bound[0])/2;
		point1.Y = bound[3]+5;
		rapidDimensionBuilder1->Style()->LineArrowStyle()->SetLeaderOrientation(NXOpen::Annotations::LeaderSideRight);
		rapidDimensionBuilder1->Measurement()->SetMethod(NXOpen::Annotations::DimensionMeasurementBuilder::MeasurementMethodHorizontal);
	}
	else
	{
		//rapidDimensionBuilder1->Measurement()->SetMethod(NXOpen::Annotations::DimensionMeasurementBuilder::MeasurementMethodVertical);
	}
    
    rapidDimensionBuilder1->Origin()->Origin()->SetValue(NULL, nullNXOpen_View, point1);
    
    rapidDimensionBuilder1->Origin()->SetInferRelativeToGeometry(true);

    NXOpen::NXObject *nXObject1;
    nXObject1 = rapidDimensionBuilder1->Commit();
    
    rapidDimensionBuilder1->Destroy(); 

}

static tag_t Create_wcs_by_view(tag_t viewTag)
{
    tag_t mx = NULL_TAG, wcs = NULL_TAG;
    double csys[9]={1,0,0,0,1,0,0,0,1},
           tol = 0,
		   mag = 0, 
		   origin[3]={0,0,0},
		   x_dir[3],
           y_dir[3],
           z_dir[3];


    UF_MODL_ask_distance_tolerance(&tol);

    /*UF_CALL(UF_MODL_ask_face_parm(face, origin, parm, pnt));
    UF_CALL(UF_MODL_ask_face_props(face, parm, pnt, x_dir, 
        junk, junk, junk, z_dir, junk));*/
	if( viewTag != NULL_TAG )
	{
		/*NXOpen::Session *theSession = NXOpen::Session::GetSession();
		NXOpen::Part *workPart(theSession->Parts()->Work());

		NXOpen::Drawings::BaseViewBuilder *baseViewBuilder1;
		Drawings::BaseView *baseView1(dynamic_cast<Drawings::BaseView *>(NXOpen::NXObjectManager::Get(viewTag)));
		baseViewBuilder1 = workPart->DraftingViews()->CreateBaseViewBuilder(baseView1);

		NXOpen::Direction* xdir = baseViewBuilder1->Style()->ViewStyleOrientation()->Ovt()->XDirection();
		NXOpen::Direction* ndir = baseViewBuilder1->Style()->ViewStyleOrientation()->Ovt()->NormalDirection();

		x_dir[0]= xdir->Vector().X;
		x_dir[1]= xdir->Vector().Y;
		x_dir[2]= xdir->Vector().Z;
		z_dir[0]= ndir->Vector().X;
		z_dir[1]= ndir->Vector().Y;
		z_dir[2]= ndir->Vector().Z;
		UF_VEC3_cross(z_dir, x_dir, y_dir);
		UF_CALL(UF_VEC3_unitize(x_dir, tol, &mag, &csys[0]));
		UF_CALL(UF_VEC3_unitize(y_dir, tol, &mag, &csys[3]));
		UF_CALL(UF_VEC3_unitize(z_dir, tol, &mag, &csys[6]));
		baseViewBuilder1->Destroy();*/
	}
	x_dir[0]= 1;
	x_dir[1]= 0;
	x_dir[2]= 0;
	z_dir[0]= 0;
	z_dir[1]= 0;
	z_dir[2]= 1;
	UF_VEC3_cross(z_dir, x_dir, y_dir);
	UF_CALL(UF_VEC3_unitize(x_dir, tol, &mag, &csys[0]));
	UF_CALL(UF_VEC3_unitize(y_dir, tol, &mag, &csys[3]));
	UF_CALL(UF_VEC3_unitize(z_dir, tol, &mag, &csys[6]));
    //UF_MTX3_ortho_normalize(csys);

    UF_CALL(UF_CSYS_create_matrix(csys, &mx));
    UF_CALL(UF_CSYS_create_temp_csys(origin, mx, &wcs));

    return wcs;
}


void RY_DWG_create_demention(tag_t partTag, tag_t viewTag ,double scale, double directions[3][3])
{
    int n_vis = 0, n_cli = 0;
    tag_t *visobj = NULL;
    tag_t *cliobj = NULL;
	double offset = 90000;
    double pt1[2]={0,0}, pt2[2]={0,0};
    UF_VIEW_ask_visible_objects(viewTag,&n_vis,&visobj,&n_cli,&cliobj);
    StlTagVector objects;
    for( int idx = 0; idx < n_vis; ++idx )
    {
        int type = 0, subtype = 0;
        UF_OBJ_ask_type_and_subtype(visobj[idx], &type, &subtype);
        /*if(type == UF_line_type || type == UF_circle_type 
            || type == UF_conic_type || type == UF_spline_type
            || type == UF_solid_silhouette_type || type == UF_section_edge_type
            && UF_line_normal_subtype == subtype)*/
		if(type == UF_line_type || type == UF_circle_type 
            || type == UF_conic_type && UF_line_normal_subtype == subtype)
        {
            objects.push_back(visobj[idx]);
        }
    }
	//tag_t csysTag = Create_wcs_by_view(viewTag);
	//double min_corner[3]={0.0},max_corner[3]={0.0},directions[3][3]={0.0},distances[3] = {0.0};
	double leftPoint[3]={0.0},rightPoint[3]={0.0},topPoint[3]={0.0},bottomPoint[3]={0.0};
	/*UF_MODL_ask_bounding_box_exact( objects[0], csysTag, min_corner, directions, distances );
	for( int i = 0; i< 3; i++ )
	{
		for( int j = 0; j< 3; j++ )
		{
			max_corner[i] = min_corner[i]+directions[j][i] * distances[j];
		}
		center[i] = (min_corner[i]+max_corner[i])/2;
	}*/
	double center[3]={0.0};
	UF_VIEW_ask_center(viewTag,center);
	for( int i = 0; i< 3; i++ )
	{
		leftPoint[i] = center[i]-directions[0][i] * offset;
		rightPoint[i] = center[i]+directions[0][i] * offset;
		topPoint[i] = center[i]+directions[1][i] * offset;
		bottomPoint[i] = center[i]-directions[1][i] * offset;
	}
	CreateDemension3(partTag,viewTag,objects,0,topPoint,bottomPoint,scale);
	CreateDemension3(partTag,viewTag,objects,1,leftPoint,rightPoint,scale);
	UF_free(visobj);
    UF_free(cliobj);
	return;
}

//------------------------------------------------------------------------------
//Callback Name: ok_cb
//------------------------------------------------------------------------------
//int autodrafting::ok_cb()
//{
//    int errorCode = 0;
//    try
//    {
//        //errorCode = apply_cb();
//		char inputfile[UF_CFI_MAX_PATH_NAME_SIZE]="";
//		char outputfile[UF_CFI_MAX_PATH_NAME_SIZE]="";
//		std::vector<Node*> SelectedNodes;
//		std::vector<NXString> typestrs = enumType->GetEnumMembers();
//		int sel = 0;
//		UI_EnumGetCurrentSel(enumType, sel);
//		NXString typeStr = typestrs[sel];
//
//		NXString savepath = nativeFolderBrowser01->GetProperties()->GetString("Path");
//
//		NXOpen::BlockStyler::Node * treeNode = tree_control0->RootNode();
//		while( NULL != treeNode )
//		{
//			SelectedNodes.push_back(treeNode);
//			treeNode = treeNode->NextNode();
//		}
//        for( int idx = 0; idx < SelectedNodes.size(); ++idx )
//        {
//            NXOpen::DataContainer *nodeData = SelectedNodes[idx]->GetNodeData();
//            std::vector<NXOpen::TaggedObject *>objects = nodeData->GetTaggedObjectVector("Data");
//            if( objects.size() > 0 )
//            {
//				StlTagVector bodies;
//				bodies.push_back(objects[0]->Tag());
//				NXString name = SelectedNodes[idx]->GetColumnDisplayText(0);
//				CreateReferenceSet(bodies,name);
//            }
//        }
//		tag_t disp = UF_PART_ask_display_part();
//		tag_t newpart = CreateDWGPart();
//		if( NULL_TAG != newpart )
//		{
//			UF_PART_ask_part_name(newpart,inputfile);
//			for( int idx = 0; idx < SelectedNodes.size(); ++idx )
//			{
//				NXOpen::DataContainer *nodeData = SelectedNodes[idx]->GetNodeData();
//				std::vector<NXOpen::TaggedObject *>objects = nodeData->GetTaggedObjectVector("Data");
//				if( objects.size() > 0 )
//				{
//					NXString name = SelectedNodes[idx]->GetColumnDisplayText(0);
//					NXString frame = SelectedNodes[idx]->GetColumnDisplayText(1);
//					NXString scale = SelectedNodes[idx]->GetColumnDisplayText(2);
//					CreateDrawingViewDWG(disp,name,frame,scale,typeStr);
//					sprintf(outputfile,"%s\\%s.dwg",savepath.GetLocaleText(),name.GetLocaleText());
//					export_sheet_to_acad_dwg2d(inputfile,outputfile,name);
//				}
//			}
//			//UF_PART_save();
//			//UF_PART_close(newpart,0,1);
//			//theSession->ApplicationSwitchImmediate("UG_APP_MODELING");
//		}
//		//UF_PART_set_display_part(disp);
//    }
//    catch(exception& ex)
//    {
//        //---- Enter your exception handling code here -----
//        errorCode = 1;
//        autodrafting::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
//    }
//    return errorCode;
//}

static void EditLableNote(  tag_t orgNote, StlNXStringVector text )
{
    Session *theSession = Session::GetSession();
    Part *workPart(theSession->Parts()->Work());
    int type = 0;
    int subType = 0;
    NXString noteStr;
    UF_OBJ_ask_type_and_subtype( orgNote, &type, &subType );
    if( UF_draft_note_subtype == subType )
    {
        Annotations::Note *note1 = (NXOpen::Annotations::Note *)NXOpen::NXObjectManager::Get(orgNote);
        Annotations::DraftingNoteBuilder *draftingNoteBuilder1;
        draftingNoteBuilder1 = workPart->Annotations()->CreateDraftingNoteBuilder((Annotations::SimpleDraftingAid *)note1);
        draftingNoteBuilder1->Text()->TextBlock()->SetText(text);
        NXObject *nXObject1;
        nXObject1 = draftingNoteBuilder1->Commit();
        draftingNoteBuilder1->Destroy();
    }
}

int autodrafting::GZ_SetDrawingNoteInformation( tag_t part, tag_t group, double scale, NXString& DrawingNO )
{
	int n = 0;
	tag_t *members = NULL;
    int defineIndex = 0;
    for( int idx = 0; idx < BodiesDefined.size(); ++idx )
    {
        if( 0 == strcmp(BodiesDefined[idx].DrawingNO.GetLocaleText(),DrawingNO.GetLocaleText()))
        {
            defineIndex = idx;
            break;
        }
    }
	UF_GROUP_ask_group_data(group, &members, &n);
	for( int idx = 0; idx < n; ++idx )
	{
		int type = 0;
        int subType = 0;
        UF_OBJ_ask_type_and_subtype( members[idx], &type, &subType );
        if( UF_draft_note_subtype == subType )//UF_tabular_note_type UF_draft_label_subtype == subType || 
        {
			char note_name[MAX_ENTITY_NAME_SIZE+1]="";
            UF_OBJ_ask_name(members[idx],note_name);
			if( 0 == strcmp("技术说明",note_name) )
			{
                StlNXStringVector tech;
                tech = BodiesDefined[defineIndex].tech;
                //tech = multiline_string0->GetValue();
                EditLableNote(members[idx],tech);
			}
			else if( 0 == strcmp("日期",note_name) )
			{
				StlNXStringVector tech;
                NXString projName = DesignDate->GetProperties()->GetString("Value");
                tech.push_back(projName);
                EditLableNote(members[idx],tech);
			}
            else if( 0 == strcmp("图名",note_name) )
			{
				StlNXStringVector tech;
                //NXString projName = drawingName->GetProperties()->GetString("Value");
                NXString projName = BodiesDefined[defineIndex].DrawingName;
                tech.push_back(projName);
                EditLableNote(members[idx],tech);
			}
            else if( 0 == strcmp("图号",note_name) )
			{
				StlNXStringVector tech;
                //NXString projName = drawingNO->GetProperties()->GetString("Value");
                tech.push_back(DrawingNO);
                EditLableNote(members[idx],tech);;
			}
            else if( 0 == strcmp("工程名称",note_name) )
			{
                StlNXStringVector tech;
                NXString projName = projectName->GetProperties()->GetString("Value");
                tech.push_back(projName);
                EditLableNote(members[idx],tech);
            }
            else if( 0 == strcmp("工程编号",note_name) )
            {
                StlNXStringVector tech;
                NXString projNO = projectNO->GetProperties()->GetString("Value");
                tech.push_back(projNO);
                EditLableNote(members[idx],tech);
			}
            else if( 0 == strcmp("比例",note_name) )
            {
                StlNXStringVector tech;
                char str[32]="";
                sprintf(str,"1:%g",scale);
                tech.push_back(str);
                EditLableNote(members[idx],tech);
			}
        }
	}
	UF_free(members);
	return 0;
}

int autodrafting::ok_cb()
{
    int errorCode = 0;
    try
    {
        //errorCode = apply_cb();
		char inputfile[UF_CFI_MAX_PATH_NAME_SIZE]="";
		char outputfile[UF_CFI_MAX_PATH_NAME_SIZE]="";
		//std::vector<Node*> SelectedNodes;
        tag_t disp = UF_PART_ask_display_part();
		std::vector<NXString> typestrs = enumType->GetEnumMembers();
		int sel = 0;
		UI_EnumGetCurrentSel(enumType, sel);
		NXString typeStr = typestrs[sel];
        double scale = doubleDwgScale->GetProperties()->GetDouble("Value");
        NXString frame = enumFrameType->GetProperties()->GetEnumAsString("Value");
		NXString savepath = nativeFolderBrowser01->GetProperties()->GetString("Path");
        std::vector<NXOpen::TaggedObject* > objects = bodySelect0->GetProperties()->GetTaggedObjectVector("SelectedObjects");
        NXString projName = projectName->GetProperties()->GetString("Value");
        NXString projNO = projectNO->GetProperties()->GetString("Value");
		NXString tuHao = drawingNO->GetProperties()->GetString("Value");

        Royal_set_obj_attr(disp,"工程名称",projName.GetLocaleText());
		Royal_set_obj_attr(disp,"工程编号",projNO.GetLocaleText());

        std::vector<Node*> SelectedNodes;
        NXOpen::BlockStyler::Node * treeNode = tree_control0->RootNode();
        while( NULL != treeNode )
        {
            SelectedNodes.push_back(treeNode);
            treeNode = treeNode->NextNode();
        }
        for( int idx = 0; idx < SelectedNodes.size(); ++idx )
        {
            StlTagVector bodies;
            NXOpen::DataContainer *nodeData = SelectedNodes[idx]->GetNodeData();
            std::vector<NXOpen::TaggedObject *>objects = nodeData->GetTaggedObjectVector("Data");
            for(int jdx = 0; jdx < objects.size(); ++jdx )
                bodies.push_back(objects[jdx]->Tag());
            if( bodies.size() > 0 )
            {
                NXString name = SelectedNodes[idx]->GetColumnDisplayText(0);
                CreateReferenceSet(bodies,name);
            }
        }
        tag_t newpart = CreateDWGPart();
        if( NULL_TAG == newpart )
            return 1;
        UF_PART_ask_part_name(newpart,inputfile);
        for( int idx = 0; idx < SelectedNodes.size(); ++idx )
        {
            NXString refname = SelectedNodes[idx]->GetColumnDisplayText(0);
            NXString frame = SelectedNodes[idx]->GetColumnDisplayText(1);
            tag_t view = NULL_TAG;
            tag_t viewl = NULL_TAG;
            tag_t viewr = NULL_TAG;
            double scale = 1;
			double direction[3][3]={0};
			double viewldir[3][3]={0};
			double viewrdir[3][3]={0};
            double viewbound[4] = {0};
            /*double viewboundl[4] = {0};
            double viewboundr[4] = {0};
			double viewcenter[3]={0};
			double pt2d[2] = {0};
			char viewName[133]="";*/
			GetTopViewProjectDirection( disp, refname, direction );
            tag_t group = CreateDrawingViewDWG(disp,view,viewl,viewr,refname,frame,typeStr,viewbound,scale);
            GZ_SetDrawingNoteInformation(newpart,group,scale,refname);
            RY_DWG_create_demention(disp,view,scale,direction);
			for( int i = 0; i< 3; i++)
				viewldir[0][i] = direction[0][i];
			for( int i = 0; i< 3; i++)
				viewldir[1][i] = direction[2][i];
            RY_DWG_create_demention(disp,viewl,scale,viewldir);
			for( int i = 0; i< 3; i++)
				viewrdir[0][i] = direction[2][i];
			for( int i = 0; i< 3; i++)
				viewrdir[1][i] = direction[1][i];
            RY_DWG_create_demention(disp,viewr,scale,viewrdir);
            UF_PART_save();
            sprintf(outputfile,"%s\\%s.dwg",savepath.GetLocaleText(),refname.GetLocaleText());
            export_sheet_to_acad_dwg2d(inputfile,outputfile,refname);
        }
        UF_PART_close(newpart,0,1);
        UF_PART_set_display_part(disp);
        theSession->ApplicationSwitchImmediate("UG_APP_MODELING");
        char cmd[512]="";
        sprintf_s(cmd,"start %s",savepath.GetLocaleText());
        system(cmd);      
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        autodrafting::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}
//------------------------------------------------------------------------------
//Callback Name: cancel_Cb
//------------------------------------------------------------------------------
int autodrafting::cancel_cb()
{
    try
    {
        //---- Enter your callback code here -----
        std::vector<Node*> nodes = tree_control0->GetSelectedNodes();
        for( int idx = 0; idx < nodes.size(); ++idx )
        {
            NXOpen::DataContainer *nodeData = nodes[idx]->GetNodeData();
            std::vector<NXOpen::TaggedObject *>objects = nodeData->GetTaggedObjectVector("Data");
            if( objects.size() > 0 )
            {
                UF_DISP_set_highlight(objects[0]->Tag(),0);
            }
        }
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        autodrafting::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}
//------------------------------------------------------------------------------
//Treelist specific callbacks
//------------------------------------------------------------------------------
//void autodrafting::OnExpandCallback (NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node)
//{
//}

//void autodrafting::OnInsertColumnCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
//{
//}

//void autodrafting::OnInsertNodeCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node)
//{
//}

//void autodrafting::OnDeleteNodeCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node)
//{
//}

//void autodrafting::OnPreSelectCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int ID, bool selected)
//{
//}

void autodrafting::OnSelectCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID, bool selected)
{
    NXOpen::DataContainer *nodeData = node->GetNodeData();
    std::vector<NXOpen::TaggedObject *>objects = nodeData->GetTaggedObjectVector("Data");
    if( objects.size() > 0 )
    {
        if( selected )
        {
            //UF_DISP_set_highlight(objects[0]->Tag(),1);
            NXString type = node->GetColumnDisplayText(1);
            NXString drawNO = node->GetColumnDisplayText(0);
            NXString status = node->GetColumnDisplayText(2);
            enumFrameType->GetProperties()->SetEnumAsString("Value",type.GetLocaleText());
            drawingNO->GetProperties()->SetString("Value",drawNO);
            std::vector<Node*> SelectedNodes = tree_control0->GetSelectedNodes();
            NXOpen::DataContainer *nodeData = SelectedNodes[0]->GetNodeData();
            std::vector<NXOpen::TaggedObject *>objects = nodeData->GetTaggedObjectVector("Data");
            bodySelect0->GetProperties()->SetTaggedObjectVector("SelectedObjects",objects);
			/*double sc = atof(scale.GetText());
			doubleDwgScale->GetProperties()->SetDouble("Value",sc);*/
            buttonDelete->GetProperties()->SetLogical("Enable",true);
            if( 0 == strcmp(status.GetLocaleText(),"隐藏"))
            {
                toggleHide->GetProperties()->SetLogical("Value",true);
            }
            else
            {
                toggleHide->GetProperties()->SetLogical("Value",false);
            }
        }
        else
        {
            std::vector<NXOpen::TaggedObject* > objectsNull;
            std::vector<NXOpen::TaggedObject* > csysObjectsNull;
            bodySelect0->GetProperties()->SetTaggedObjectVector("SelectedObjects",objectsNull);
            //coord_system0->GetProperties()->SetTaggedObjectVector("SelectedObjects",objectsNull);
            //UF_DISP_set_highlight(objects[0]->Tag(),0);
            buttonDelete->GetProperties()->SetLogical("Enable",false);
        }
    }
}

//void autodrafting::OnStateChangeCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int state)
//{
//}

//NXString autodrafting::ToolTipTextCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
//{
//}

//int autodrafting::ColumnSortCallback(NXOpen::BlockStyler::Tree *tree, int columnID, NXOpen::BlockStyler::Node *node1, NXOpen::BlockStyler::Node *node2)
//{
//}

//NXString autodrafting::StateIconNameCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int state)
//{
//}

//NXOpen::BlockStyler::Tree::BeginLabelEditState autodrafting::OnBeginLabelEditCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
//{
//}

//NXOpen::BlockStyler::Tree::EndLabelEditState autodrafting::OnEndLabelEditCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int, NXString editedText)
//{
//}

//NXOpen::BlockStyler::Tree::EditControlOption autodrafting::OnEditOptionSelectedCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID, int selectedOptionID, NXString selectedOptionText, NXOpen::BlockStyler::Tree::ControlType type)
//{
//}

//NXOpen::BlockStyler::Tree::ControlType autodrafting::AskEditControlCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
//{
//}

//void autodrafting::OnMenuCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID )
//{
//}

//void autodrafting::OnMenuSelectionCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int menuItemID)
//{
//}

//NXOpen::BlockStyler::Node::DropType autodrafting::IsDropAllowedCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID, NXOpen::BlockStyler::Node *targetNode, int targetColumnID)
//{
//}

//NXOpen::BlockStyler::Node::DragType autodrafting::IsDragAllowedCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
//{
//}

//bool autodrafting::OnDropCallback(NXOpen::BlockStyler::Tree *tree, std::vector<NXOpen::BlockStyler::Node *> node, int columnID, NXOpen::BlockStyler::Node *targetNode, int targetColumnID, NXOpen::BlockStyler::Node::DropType dropType, int dropMenuItemId)
//{
//}

//void autodrafting::OnDropMenuCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID, NXOpen::BlockStyler::Node *targetNode, int targetColumnID)
//{
//}

//void autodrafting::OnDefaultAction(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *node, int columnID)
//{
//}


//------------------------------------------------------------------------------
//Function Name: GetBlockProperties
//Description: Returns the propertylist of the specified BlockID
//------------------------------------------------------------------------------
PropertyList* autodrafting::GetBlockProperties(const char *blockID)
{
    return theDialog->GetBlockProperties(blockID);
}
