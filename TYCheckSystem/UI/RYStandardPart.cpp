//==============================================================================
//  WARNING!!  This file is overwritten by the Block UI Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  C:\NXDemo\all\application\RYStandardPart.cpp
//
//        This file was generated by the NX Block UI Styler
//        Created by: Administrator
//              Version: NX 10
//              Date: 10-11-2018  (Format: mm-dd-yyyy)
//              Time: 14:09 (Format: hh-mm)
//
//==============================================================================

//==============================================================================
//  Purpose:  This TEMPLATE file contains C++ source to guide you in the
//  construction of your Block application dialog. The generation of your
//  dialog file (.dlx extension) is the first step towards dialog construction
//  within NX.  You must now create a NX Open application that
//  utilizes this file (.dlx).
//
//  The information in this file provides you with the following:
//
//  1.  Help on how to load and display your Block UI Styler dialog in NX
//      using APIs provided in NXOpen.BlockStyler namespace
//  2.  The empty callback methods (stubs) associated with your dialog items
//      have also been placed in this file. These empty methods have been
//      created simply to start you along with your coding requirements.
//      The method name, argument list and possible return values have already
//      been provided for you.
//==============================================================================

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include "RYStandardPart.hpp"
using namespace NXOpen;
using namespace NXOpen::BlockStyler;
using namespace YExcel;

//------------------------------------------------------------------------------
// Initialize static variables
//------------------------------------------------------------------------------
Session *(RYStandardPart::theSession) = NULL;
UI *(RYStandardPart::theUI) = NULL;
//StlNXStringVector classNames1;
//StlNXStringVector classifyregfiles;
//StlNXStringVector classNames2;
//StlNXStringVectorVector regdata;

StandardPartData RoyStdData;


//------------------------------------------------------------------------------
// Constructor for NX Styler class
//------------------------------------------------------------------------------
RYStandardPart::RYStandardPart()
{
    try
    {
        // Initialize the NX Open C++ API environment
		UF_initialize();
        RYStandardPart::theSession = NXOpen::Session::GetSession();
        RYStandardPart::theUI = UI::GetUI();
        theDlxFileName = "RYStandardPart.dlx";
        theDialog = RYStandardPart::theUI->CreateDialog(theDlxFileName);
        // Registration of callback functions
        theDialog->AddApplyHandler(make_callback(this, &RYStandardPart::apply_cb));
        theDialog->AddOkHandler(make_callback(this, &RYStandardPart::ok_cb));
        theDialog->AddUpdateHandler(make_callback(this, &RYStandardPart::update_cb));
		theDialog->AddCancelHandler(make_callback(this, &RYStandardPart::cancel_cb));
        theDialog->AddInitializeHandler(make_callback(this, &RYStandardPart::initialize_cb));
        theDialog->AddDialogShownHandler(make_callback(this, &RYStandardPart::dialogShown_cb));
		
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        throw;
    }
}

//------------------------------------------------------------------------------
// Destructor for NX Styler class
//------------------------------------------------------------------------------
RYStandardPart::~RYStandardPart()
{
    if (theDialog != NULL)
    {
        delete theDialog;
        theDialog = NULL;
    }
	UF_terminate();
}
//------------------------------- DIALOG LAUNCHING ---------------------------------
//
//    Before invoking this application one needs to open any part/empty part in NX
//    because of the behavior of the blocks.
//
//    Make sure the dlx file is in one of the following locations:
//        1.) From where NX session is launched
//        2.) $UGII_USER_DIR/application
//        3.) For released applications, using UGII_CUSTOM_DIRECTORY_FILE is highly
//            recommended. This variable is set to a full directory path to a file 
//            containing a list of root directories for all custom applications.
//            e.g., UGII_CUSTOM_DIRECTORY_FILE=$UGII_ROOT_DIR\menus\custom_dirs.dat
//
//    You can create the dialog using one of the following way:
//
//    1. USER EXIT
//
//        1) Create the Shared Library -- Refer "Block UI Styler programmer's guide"
//        2) Invoke the Shared Library through File->Execute->NX Open menu.
//
//------------------------------------------------------------------------------
//extern "C" DllExport void  ufusr(char *param, int *retcod, int param_len)
void RY_Standard_Part()
{
    RYStandardPart *theRYStandardPart = NULL;
    try
    {
        theRYStandardPart = new RYStandardPart();
        // The following method shows the dialog immediately
        theRYStandardPart->Show();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    if(theRYStandardPart != NULL)
    {
        delete theRYStandardPart;
        theRYStandardPart = NULL;
    }
}

//------------------------------------------------------------------------------
// This method specifies how a shared image is unloaded from memory
// within NX. This method gives you the capability to unload an
// internal NX Open application or user  exit from NX. Specify any
// one of the three constants as a return value to determine the type
// of unload to perform:
//
//
//    Immediately : unload the library as soon as the automation program has completed
//    Explicitly  : unload the library from the "Unload Shared Image" dialog
//    AtTermination : unload the library when the NX session terminates
//
//
// NOTE:  A program which associates NX Open applications with the menubar
// MUST NOT use this option since it will UNLOAD your NX Open application image
// from the menubar.
//------------------------------------------------------------------------------
//extern "C" DllExport int ufusr_ask_unload()
//{
//    //return (int)Session::LibraryUnloadOptionExplicitly;
//    return (int)Session::LibraryUnloadOptionImmediately;
//    //return (int)Session::LibraryUnloadOptionAtTermination;
//}

//------------------------------------------------------------------------------
// Following method cleanup any housekeeping chores that may be needed.
// This method is automatically called by NX.
//------------------------------------------------------------------------------
//extern "C" DllExport void ufusr_cleanup(void)
//{
//    try
//    {
//        //---- Enter your callback code here -----
//    }
//    catch(exception& ex)
//    {
//        //---- Enter your exception handling code here -----
//        RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
//    }
//}

int RYStandardPart::Show()
{
    try
    {
        theDialog->Show();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}

//------------------------------------------------------------------------------
//---------------------Block UI Styler Callback Functions--------------------------
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//Callback Name: initialize_cb
//------------------------------------------------------------------------------
void RYStandardPart::initialize_cb()
{
    try
    {
        group1 = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group1"));
        string_search = dynamic_cast<NXOpen::BlockStyler::StringBlock*>(theDialog->TopBlock()->FindBlock("string_search"));
        button_search = dynamic_cast<NXOpen::BlockStyler::Button*>(theDialog->TopBlock()->FindBlock("button_search"));
        list_search_result = dynamic_cast<NXOpen::BlockStyler::ListBox*>(theDialog->TopBlock()->FindBlock("list_search_result"));
        group_edit = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group_edit"));
        select_std_edit = dynamic_cast<NXOpen::BlockStyler::SelectObject*>(theDialog->TopBlock()->FindBlock("select_std_edit"));
        group_type = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group_type"));
        enum_1 = dynamic_cast<NXOpen::BlockStyler::Enumeration*>(theDialog->TopBlock()->FindBlock("enum_1"));
        enum_2 = dynamic_cast<NXOpen::BlockStyler::Enumeration*>(theDialog->TopBlock()->FindBlock("enum_2"));
        enum_3 = dynamic_cast<NXOpen::BlockStyler::Enumeration*>(theDialog->TopBlock()->FindBlock("enum_3"));
        assyGroup = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("assyGroup"));
        parentNode = dynamic_cast<NXOpen::BlockStyler::Enumeration*>(theDialog->TopBlock()->FindBlock("parentNode"));
        stdPartName = dynamic_cast<NXOpen::BlockStyler::StringBlock*>(theDialog->TopBlock()->FindBlock("stdPartName"));
        group_legend = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group_legend"));
        label_legend = dynamic_cast<NXOpen::BlockStyler::Label*>(theDialog->TopBlock()->FindBlock("label_legend"));
        group_paras = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group_paras"));
        list_box0 = dynamic_cast<NXOpen::BlockStyler::ListBox*>(theDialog->TopBlock()->FindBlock("list_box0"));
        double_para = dynamic_cast<NXOpen::BlockStyler::DoubleBlock*>(theDialog->TopBlock()->FindBlock("double_para"));
		enum_nokeyinPara = dynamic_cast<NXOpen::BlockStyler::Enumeration*>(theDialog->TopBlock()->FindBlock("enum_nokeyinPara"));
        group_pos = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group_pos"));
        point_pos = dynamic_cast<NXOpen::BlockStyler::SpecifyPoint*>(theDialog->TopBlock()->FindBlock("point_pos"));
        coord_system_pos = dynamic_cast<NXOpen::BlockStyler::SpecifyCSYS*>(theDialog->TopBlock()->FindBlock("coord_system_pos"));
        manip_pos = dynamic_cast<NXOpen::BlockStyler::SpecifyOrientation*>(theDialog->TopBlock()->FindBlock("manip_pos"));
        group = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group"));
        toggle_pocket = dynamic_cast<NXOpen::BlockStyler::Toggle*>(theDialog->TopBlock()->FindBlock("toggle_pocket"));
		toggle_preview = dynamic_cast<NXOpen::BlockStyler::Toggle*>(theDialog->TopBlock()->FindBlock("toggle_preview"));
        bodyForcePock = dynamic_cast<NXOpen::BlockStyler::BodyCollector*>(theDialog->TopBlock()->FindBlock("bodyForcePock"));
        //------------------------------------------------------------------------------
        //Registration of ListBox specific callbacks
        //------------------------------------------------------------------------------
        //list_box0->SetAddHandler(make_callback(this, &RYStandardPart::AddCallback));
        
        //list_box0->SetDeleteHandler(make_callback(this, &RYStandardPart::DeleteCallback));
        
        //------------------------------------------------------------------------------
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

extern int XINGTAI_ASSY_clone(char templateName[MAX_FSPEC_SIZE], char nameRule[MAX_FSPEC_SIZE],char path_str[MAX_FSPEC_SIZE], char new_part_name[MAX_FSPEC_SIZE])
{
    int err;
    UF_CLONE_operation_class_t operation_class=UF_CLONE_clone_operation ; 
    UF_CLONE_action_t default_action=UF_CLONE_clone;  
    UF_PART_load_status_t load_status; 
    UF_CLONE_name_rule_def_t namerule; 
    UF_CLONE_naming_failures_t naming_failures; 
    UF_CLONE_naming_technique_t naming_technique;
    err = UF_CLONE_initialise(operation_class); 
    err = UF_CLONE_init_naming_failures(&naming_failures); 
    if(UF_CLONE_add_assembly ( templateName, & load_status )) 
		return 1;
    UF_free_string_array(load_status.n_parts,load_status.file_names);
    UF_free(load_status.statuses);

    err = UF_CLONE_set_def_action(default_action); 
    err = UF_CLONE_set_def_directory(path_str);  
    naming_technique= UF_CLONE_naming_rule;
    err = UF_CLONE_set_def_naming(naming_technique);
    namerule.type=UF_CLONE_prepend_string; 
    namerule.new_string=nameRule; 

	/*uc4576(templateName, 2, path_str, new_part_name);

	namerule.type = UF_CLONE_replace_string;
    namerule.base_string = new_part_name;
    namerule.new_string  = nameRule;*/

    err = UF_CLONE_set_name_rule(&namerule,&naming_failures); 
	NXFUN_ASSY_clone_set_no_log();
    err = UF_CLONE_perform_clone(&naming_failures); 
    if(naming_failures.n_failures >0) 
    {
        UF_free_string_array(naming_failures.n_failures,naming_failures.input_names);
        UF_free_string_array(naming_failures.n_failures,naming_failures.output_names);
        UF_free(naming_failures.statuses);
    }
    //else
    //{
    //    PrintErrorMessage(err);
    //}
    UF_CLONE_terminate();   

    //UF_PART_load_status_t   error_status;
    strcpy(new_part_name,path_str);
    strcat(new_part_name,"\\");    
    strcat(new_part_name, nameRule);
    /*UF_PART_open_quiet( new_part_name, newPart, &error_status );
    UF_free_string_array( error_status.n_parts, error_status.file_names );
    UF_free( error_status.statuses );*/
    return 0;
}
void build_temp_filespec(char *fspec, int ftype, char *new_spec)
{
    char *tmp_dir;

    UF_translate_variable("UGII_TMP_DIR", &tmp_dir);
	uc4575(tmp_dir, ftype, fspec, new_spec);
}
static int StandardPartClonePart(const char *source_part, char *output_part)
{
	int irc = 0;
    /*UF_CLONE_naming_failures_t  name_failures;
    char output_path[UF_CFI_MAX_PATH_NAME_SIZE], output_name[UF_CFI_MAX_FILE_NAME_SIZE];

    irc = uc4576(output_part, 2, output_path, output_name);

    irc = UF_CLONE_initialise(UF_CLONE_clone_operation);

    int err = UF_CLONE_add_part(source_part);
	err = UF_CLONE_init_naming_failures(&name_failures);
    if ( err != 0)
    {
        char msg[133];
        UF_get_fail_message( err, msg );
        return -1;
    }

    err = UF_CLONE_set_def_action(UF_CLONE_clone);
    if (UF_CLONE_set_def_directory(output_path) != 0)
        return -2;
	char clone_log[MAX_FSPEC_SIZE+1]="";
	build_temp_filespec("Clone_Existing_Import", 47, clone_log);
	UF_CLONE_set_logfile(clone_log);

    err = UF_CLONE_set_naming(source_part, UF_CLONE_user_name, output_part);
	err = UF_CLONE_set_dryrun(false);

    NXFUN_ASSY_clone_set_no_log();
    err = UF_CLONE_perform_clone(&name_failures);
    if (name_failures.n_failures > 0)
    {
        UF_free(name_failures.statuses);
        UF_free_string_array(name_failures.n_failures, name_failures.input_names);
        UF_free_string_array(name_failures.n_failures, name_failures.output_names);
        return -3;
    }
    err = UF_CLONE_terminate();*/
    uc4567( source_part,output_part,UF_CFI_COPY_NEVER_REPLACE,0,2);
    UF_CFI_ask_file_exist(output_part,&irc);
    return irc;
}

//int GetRegFileData( char* fileFullName, StlNXStringVector& className2, StlNXStringVectorVector& regData )
//{
//	BasicExcel excel;
//	className2.clear();
//	regData.clear();
//	bool isOk = excel.Load(fileFullName);	
//	if( isOk )
//	{
//		int numSheet = excel.GetTotalWorkSheets();
//		for( int idx = 0; idx < numSheet; ++idx )
//		{
//			const wchar_t* sheetName = excel.GetUnicodeSheetName(idx);
//			className2.push_back(WCHARTOCHAR(sheetName));
//			BasicExcelWorksheet* sheet1 = excel.GetWorksheet(sheetName);
//			StlNXStringVector sheetclassNames;
//			if (sheet1)
//			{
//				size_t maxRows = sheet1->GetTotalRows();
//				for(int i = 1; i < maxRows; i++)
//				{
//					BasicExcelCell *cel = sheet1->Cell(i,0);
//					const wchar_t* name = cel->GetWString();
//					sheetclassNames.push_back(NXString(WCHARTOCHAR(name)));
//				}
//			}
//			regData.push_back(sheetclassNames);
//		}
//	}
//	return regData.size();
//}

int ConvertStr(char *pstr)
{
    int len = strlen(pstr);
    for(int i = 0; i < len; i++)
    {
        if( pstr[i] >= 'a' && pstr[i] <= 'z')
             pstr[i] = pstr[i] - 32;
    }
    return 0;
}


logical IsContainStr( const char* strlib, const char* substr )
{
    char *p = NULL;
    StlNXStringVector strv;
    logical result = true;
    char* strp = (char *)malloc(strlen(substr) + 1) ;
    char* str = (char *)malloc(strlen(strlib) + 1) ;
    strcpy(strp,substr);
    strcpy(str,strlib);
    ConvertStr(strp);
    ConvertStr(str);
    p=strtok(strp,"*");
    while(p!=NULL)
    {
        strv.push_back(p);
        p=strtok(NULL,"*");
    }
    for( int idx = 0; idx < strv.size(); ++idx )
    {
        char* p1 = strstr(str,strv[idx].GetText());
        if( p1 == NULL )
        {
            result = false;
            break;
        }
    }
    free(strp);
    return result;
}
//------------------------------------------------------------------------------
//Callback Name: dialogShown_cb
//This callback is executed just before the dialog launch. Thus any value set 
//here will take precedence and dialog will be launched showing that value. 
//------------------------------------------------------------------------------
void RYStandardPart::dialogShown_cb()
{
    try
    {
        //---- Enter your callback code here -----
        /*Selection *selmgr;
        selmgr = theUI->SelectionManager();
        int i = selmgr->GetNumSelectedObjects();
        if( i > 0 )
        group_edit->GetProperties()->SetLogical("Show",true);
        else
        group_edit->GetProperties()->SetLogical("Show",false);*/
		//time(&start);
		first = 0;
		newCopy = false;
        manip_pos->GetProperties()->SetLogical("Show",false);
        point_pos->GetProperties()->SetLogical("Show",false);
        //coord_system_pos->GetProperties()->SetLogical("Show",false);
        group_edit->GetProperties()->SetLogical("Show",false);
        parentNode->GetProperties()->SetLogical("Show",false);
        button_search->GetProperties()->SetLogical("Show",false);
		toggle_preview->GetProperties()->SetLogical("Show",false);
		stdPreviewInstance = NULL_TAG;
        // Load a workbook with one sheet, display its contents and save into another file.
        //const char *env_name = "UGII_USER_DIR";
        const char *env_name = getenv("ROYAL_STANDARD_DIR");
        if( env_name != NULL )
        {
            if( !RoyStdData.GetIsInit() )
            {
                RoyStdData.InitalData(env_name,"\\standard\\RYStandardReg.xls");
            }
            enum_1->GetProperties()->SetEnumMembers("Value", RoyStdData.GetFirstClassNames());
            enum_2->GetProperties()->SetEnumMembers("Value", RoyStdData.GetSecondClassNames());
            enum_3->GetProperties()->SetEnumMembers("Value", RoyStdData.GetThirdClassNames());
            enum_1->GetProperties()->SetEnum("Value",RoyStdData.GetClass1Index());
            enum_2->GetProperties()->SetEnum("Value",RoyStdData.GetClass2Index());
            enum_3->GetProperties()->SetEnum("Value",RoyStdData.GetClass3Index());
            UpdateExpUI();
			StlNXStringVector results,namestosearch;
            NXString key = string_search->GetProperties()->GetString("Value");
            char* keystr = UTF8ToANSI(key.GetText());
			if( strlen(keystr) > 0)
			{
				namestosearch =RoyStdData.GetStandardSearchDataName();
				for( int idx = 0; idx < namestosearch.size(); ++idx )
				{
					if(IsContainStr(namestosearch[idx].GetText(),keystr))
					{
						results.push_back(namestosearch[idx]);
					}
				}
				UI_ListBox_SetItems(list_search_result,results);
			}
        }
        else
        {
            RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, "Can not find ROYAL_STANDARD_DIR");
        }
		
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

extern int report( char *file, int line, char *call, int irc)
{
	if (irc)    
	{
		char messg[MAX_LINE_SIZE + 1], str1[100];

		(UF_get_fail_message(irc, messg)) ?
		sprintf(str1, "returned a %d\n", irc) :
		sprintf(str1, "returned error %d:  %s\n", irc, messg);
#ifdef _DEBUG
		{
			char str[300], fName[MAX_ENTITY_NAME_SIZE+1], ext[_MAX_EXT];

			_splitpath(file, NULL, NULL, fName, ext);
			sprintf(str, "%s%s, line %d:  %s\n", fName, ext, line, call);
			strcat(str, str1);
			
			UF_UI_open_listing_window();
			UF_UI_write_listing_window(str);
		}
#else
		UF_UI_set_status(str1);
#endif
	}
	return(irc);
}

int pock_with_select_tool_and_target2(tag_t tool_occ,tag_t sel_target)
{
	//tag_t tool_occ;
	tag_t tool_pro,target_pro;
	tag_t from_part_occ,to_part_occ;
	tag_t ref_tag=NULL_TAG;
	tag_p_t mebers;
	int  num_mebers,i;
	char refset_name[MAX_ENTITY_NAME_SIZE+1] ;
	double origin[3] ;
	double csys_matrix[9] ;
	tag_t feat_waved=NULL_TAG,body_waved=NULL_TAG;
    tag_t workpart;
	tag_t tem_workpart;

	workpart=UF_ASSEM_ask_work_part();

	if (UF_ASSEM_is_occurrence(sel_target))
	{
		to_part_occ=UF_ASSEM_ask_part_occurrence(sel_target);
 		target_pro=UF_ASSEM_ask_prototype_of_occ(sel_target);
		tem_workpart=UF_ASSEM_ask_prototype_of_occ(to_part_occ);
	}
	else
	{
		target_pro=sel_target;
		to_part_occ=NULL_TAG;
		tem_workpart=workpart;
	}

	if (UF_ASSEM_is_occurrence(tool_occ))
	{
		//tool_occ=UF_ASSEM_ask_part_occurrence(sel_tool);
		tool_pro=UF_ASSEM_ask_prototype_of_occ(tool_occ);
		from_part_occ=tool_occ;
	}
 	

  	UF_CALL(UF_OBJ_cycle_by_name_and_type(tool_pro,"FALSE",UF_reference_set_type, TRUE, &ref_tag));
 	
    UF_CALL(UF_ASSEM_ask_ref_set_data(ref_tag,refset_name,origin,csys_matrix,&num_mebers,&mebers));

	if( workpart != tem_workpart )
		UF_CALL(UF_ASSEM_set_work_part(tem_workpart));
	for (i=0;i<num_mebers;i++)
 	{
		int type,subtype,err;
		tag_t xform=NULL_TAG;
		int num_results;
		tag_t *resultbodies;
		int   result[1];

 		if (UF_OBJ_ask_type_and_subtype(mebers[i],&type,&subtype)==0
 			&&type==UF_solid_type&&subtype==UF_solid_body_subtype)
 		{
			//UF_CALL(UF_ASSEM_set_work_part(tem_workpart));
			
 			UF_CALL(UF_SO_create_xform_assy_ctxt(target_pro,from_part_occ,to_part_occ,&xform));

 			UF_CALL(UF_WAVE_create_linked_body(mebers[i],xform,target_pro,TRUE,&feat_waved));
			
			UF_CALL(UF_MODL_ask_feat_body(feat_waved,&body_waved));
			
			//UF_CALL(UF_ASSEM_set_work_part(tem_workpart));
			UF_MODL_check_interference(target_pro,1,&body_waved,result);
			if( result[0]==1 )
			{
				err=UF_MODL_subtract_bodies(target_pro,body_waved,&num_results,&resultbodies);
				if (err)
				{
					UF_CALL(UF_OBJ_delete_object(body_waved));
				}
				UF_free(resultbodies);
			}
			else
			{
				UF_CALL(UF_OBJ_delete_object(body_waved));
			}
 		}
	}
	UF_free(mebers);
	if( workpart != tem_workpart )
		UF_CALL(UF_ASSEM_set_work_part(workpart));
	return 0;
}

static int Royal_ask_refset_objs( char *ref_set_name , 
                             tag_t part_occ , 
                             StlTagVector& objlist )
{
    int i = 0 ,
		j = 0 ,
		err = 0 ,
		type = 0 ,
		subtype = 0 ,
		num_occ = 0 ,
		n_members = 0 ;
    tag_t ref_set = NULL_TAG , 
		  part_tag = NULL_TAG ,
		  * members = NULL ,
		  * body_occ = NULL ;
	
    if( UF_ASSEM_is_occurrence( part_occ ) )
	{
        part_tag = UF_ASSEM_ask_prototype_of_occ( part_occ ) ;
	}
	
    err = UF_OBJ_cycle_by_name_and_type( part_tag , ref_set_name , UF_reference_set_type , true , & ref_set ) ;
    if ( err || ref_set == NULL_TAG )
        return -1;
	
    UF_ASSEM_ask_ref_set_members( ref_set , & n_members , & members ) ;
    for( i = 0 ; i < n_members ; i ++ )
    {
        err = UF_OBJ_ask_type_and_subtype( members[ i ] , & type , & subtype ) ;
        if ( err == 0 && type == UF_solid_type && subtype == UF_solid_body_subtype &&
 		     UF_OBJ_ALIVE == UF_OBJ_ask_status( members[ i ] ) )
		{
			num_occ = UF_ASSEM_ask_occs_of_entity( members[ i ] , & body_occ ) ;
			for( j = 0 ; j < num_occ ; j ++ )
			{
				if( part_occ == UF_ASSEM_ask_part_occurrence( body_occ[ j ] ) )
				{
					objlist.push_back(body_occ[ j ]);
				}
			}
			if( body_occ != NULL )
			{
				UF_free( body_occ ) ;
				body_occ = NULL ;
			}           
		}
    }
    UF_free( members ) ;
	return objlist.size() ;
}

int Royal_standard_pocket(tag_t tool_occ, StlTagVector target_list,StlTagVector target_force)
{
	tag_t  target = NULL_TAG;
	int   result[1];
    StlTagVector  true_objs;
    int num_true = Royal_ask_refset_objs("TRUE",tool_occ,true_objs);
	for (int i=0;i<target_list.size();i++)
	{
        int idx = -1;
        logical intersect = false;
		target = target_list[i];
        if(target_force.size()>0)
        {
            idx = vFind(target_force,target);
        }
        if( idx > -1 )
        {
            intersect = true;
        }
        else
        {
            for (int j=0;j<num_true;j++)
            {
                UF_MODL_check_interference(target,1,&true_objs[j],result);
                if (result[0]==1&&target != true_objs[j])
                {
                    intersect = true;
                    break;
                }
            }
        }
        if( intersect )
            UF_CALL(pock_with_select_tool_and_target2(tool_occ,target));
	}
	return 0;
}

//void Royal_set_obj_attr( tag_t obj_tag, const char* title, const char *name_str )
//{
//	int err;
//	UF_ATTR_value_t value;
//	if( UF_ASSEM_is_occurrence( obj_tag ))
//	{
//		obj_tag = UF_ASSEM_ask_prototype_of_occ ( obj_tag ) ;
//    }
//	value.type = UF_ATTR_string;
//	value.value.string = (char*)name_str;
//	err = UF_ATTR_assign( obj_tag, (char*)title, value );
//}


//  check current idxs, idxs same ,instance exist, update parameters,
//  idxs not the same, instance exist, need delete instance, recreate preview

void RYStandardPart::PrieviewAddSTD( int updateflag )
{
	logical isPreview = false;//toggle_preview->GetProperties()->GetLogical("Value");
	if( !isPreview || first < 1 )
	{
		return;
	}
	int errorCode = 0;
	char stdName[133] = "";
	NXString stdNameNXStr = stdPartName->GetProperties()->GetString("Value");
	sprintf(stdName,"%s.prt",stdNameNXStr.GetText());
	if( strlen(stdName) < 5)
	{
		RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeInformation, "命名不能为空");
		return;
	}
	if(NULL_TAG != stdPreviewInstance)
	{
		char fname[MAX_FSPEC_BUFSIZE] = "";
		char desName[MAX_FSPEC_BUFSIZE] = "";
		char part_fspec1[ MAX_FSPEC_BUFSIZE ]="";
		tag_t cur_preview_std_tag = UF_ASSEM_ask_child_of_instance(stdPreviewInstance);
		UF_PART_ask_part_name(cur_preview_std_tag,part_fspec1);
		uc4576(part_fspec1, 2, desName, fname);
		if(0 != strcmpi(fname,stdName))
		{
			UF_ASSEM_remove_instance(stdPreviewInstance);
			stdPreviewInstance = NULL_TAG;
			if( newCopy )
			{
				uc4561(part_fspec1,2);
			}
		}
	}
	try
	{
		//---- Enter your callback code here -----
		Point3d originPoint;
		tag_t std_occ = NULL_TAG;
		double org[3] = {0.0}, csys[6] = {1,0,0,0,1,0};
		Part *workPart(theSession->Parts()->Work());
		StlNXStringVector all_express=list_box0->GetProperties()->GetStrings("ListItems");
		RoyStdData.SetLastUIExpressions(all_express);
		std::vector<NXOpen::TaggedObject* > csysObjects = coord_system_pos->GetProperties()->GetTaggedObjectVector("SelectedObjects");
		if( csysObjects.size() > 0 )
		{
			tag_t csys_tag = csysObjects[0]->Tag();
			NXOpen::CoordinateSystem *coord_system = (NXOpen::CoordinateSystem *)NXOpen::NXObjectManager::Get(csys_tag);
			originPoint =  coord_system->Origin(); 
			NXOpen::NXMatrix *matrix = coord_system->Orientation();
			Matrix3x3 matrix33 = matrix->Element();
			csys[0] = matrix33.Xx;
			csys[1] = matrix33.Xy;
			csys[2] = matrix33.Xz;
			csys[3] = matrix33.Yx;
			csys[4] = matrix33.Yy;
			csys[5] = matrix33.Yz;
		}
		org[0] = originPoint.X; org[1] = originPoint.Y;org[2] = originPoint.Z;
		if( NULL_TAG == stdPreviewInstance )
		{
			int status = 0;
			tag_t oldWork = NULL_TAG;
			tag_t instance = NULL_TAG;
			NXString cloneName;

			char sourceName[133] = "";
			char part_fspec[ MAX_FSPEC_BUFSIZE ]="";
			
			char desName[133] = "";
			UF_PART_load_status_t error_status;

			char fname[133] = "";
			char assem_path[133] = "";
			UF_PART_ask_part_name(workPart->Tag(),part_fspec);
			
			
			uc4576(part_fspec, 2, desName, fname);
			strcpy(assem_path,desName);
			strcat(desName,"\\");
			strcat(desName, stdName);
			//strcat(desName, ".prt");

			NXString stdModelFile = RoyStdData.GetCurrentStdPartModel();

			UF_CFI_ask_file_exist( desName, &status);
			if( 0 == status )
			{
				int recover = theUI->NXMessageBox()->Show("同名文件已经存在", NXOpen::NXMessageBox::DialogTypeQuestion,"是否添加实例？");
				if( 1 == recover )
				{
					UF_ASSEM_add_part_to_assembly(workPart->Tag(),desName,"TRUE",NULL,org,csys,-1,&instance,&error_status);
					UF_PART_free_load_status(&error_status);
					stdPreviewInstance = instance;
				}
				else
					return;
			}
			else
			{
				StandardPartClonePart(stdModelFile.getText(), desName );
				newCopy = true;
				int err = UF_ASSEM_add_part_to_assembly(workPart->Tag(),desName,"TRUE",NULL,org,csys,-1,&instance,&error_status);
				if(err)
				{
					UF_free_string_array(error_status.n_parts, error_status.file_names);
					UF_free(error_status.statuses);
					std_occ = NULL_TAG;
				}
				else
				{
					logical ispram = RoyStdData.GetCurrentStdPartIsPara();//false;//
					if(ispram)
					{
						//参数化驱动
						tag_t work_occ, std_tag;
						work_occ = UF_ASSEM_ask_work_occurrence();
						std_tag = UF_ASSEM_ask_child_of_instance(instance);
						std_occ = UF_ASSEM_ask_part_occ_of_inst(work_occ, instance);
						UF_ASSEM_set_work_occurrence(std_occ);	
						Royal_STD_parametrize_part( all_express, std_tag);
						UF_ASSEM_set_work_part(workPart->Tag());
					}
					stdPreviewInstance = instance;
				}
				UF_PART_free_load_status(&error_status);
			}
		}
		else
		{
			if(1==updateflag )
			{
				logical ispram = RoyStdData.GetCurrentStdPartIsPara();//false;//
				if(ispram)
				{
					//参数化驱动
					tag_t work_occ, std_tag;
					work_occ = UF_ASSEM_ask_work_occurrence();
					std_tag = UF_ASSEM_ask_child_of_instance(stdPreviewInstance);
					std_occ = UF_ASSEM_ask_part_occ_of_inst(work_occ, stdPreviewInstance);
					UF_ASSEM_set_work_occurrence(std_occ);	
					Royal_STD_parametrize_part( all_express, std_tag);
					UF_ASSEM_set_work_part(workPart->Tag());
				}
			}
			else//reposition instance
			{
				UF_ASSEM_reposition_instance(stdPreviewInstance,org,csys);
			}
		}
	}
	catch(exception& ex)
	{
		//---- Enter your exception handling code here -----
		errorCode = 1;
		RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
	}
}

//------------------------------------------------------------------------------
//Callback Name: apply_cb
//------------------------------------------------------------------------------

int RYStandardPart::apply_cb()
{
    int errorCode = 0;
	//logical isPreview = toggle_preview->GetProperties()->GetLogical("Value");
	logical isPreview = false;
	if( isPreview && stdPreviewInstance != NULL_TAG )
	{
		//UF_PART_save();
		return 0;
	}
    try
    {
        //---- Enter your callback code here -----
        int status = 0;
        tag_t oldWork = NULL_TAG;
        tag_t instance = NULL_TAG;
        NXString cloneName;
        //char *p_env = getenv("UGII_USER_DIR");
        char sourceName[133] = "";
        char part_fspec[ MAX_FSPEC_BUFSIZE ]="";
        char desName[133] = "";
        double org[3] = {0.0}, csys[6] = {1,0,0,0,1,0};
        UF_PART_load_status_t error_status;
		tag_t std_occ = NULL_TAG;
		char fname[133] = "";
        char assem_path[133] = "";

		StlNXStringVector all_express=list_box0->GetProperties()->GetStrings("ListItems");
		RoyStdData.SetLastUIExpressions(all_express);

        Part *workPart(theSession->Parts()->Work());
        UF_PART_ask_part_name(workPart->Tag(),part_fspec);
        

		const char* stdName = stdPartName->GetProperties()->GetString("Value").GetText();
		if( strlen(stdName) < 1)
		{
			RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeInformation, "命名不能为空");
			return 1;
		}
        uc4576(part_fspec, 2, desName, fname);
		strcpy(assem_path,desName);
        strcat(desName,"\\");
        strcat(desName, stdPartName->GetProperties()->GetString("Value").GetText());
        strcat(desName, ".prt");

		int idx1 = enum_1->GetProperties()->GetEnum("Value");
		int idx2 = enum_2->GetProperties()->GetEnum("Value");
		int idx3 = enum_3->GetProperties()->GetEnum("Value");
		NXString stdModelFile = RoyStdData.GetCurrentStdPartModel();
        //sprintf(sourceName,"%s\\standard\\screw.prt",p_env);
        
        //Point3d originPoint = point_pos->GetProperties()->GetPoint("Point");
		/*Point3d originPoint = manip_pos->GetProperties()->GetPoint("Origin");
		Vector3d vecDirX = manip_pos->GetProperties()->GetVector("XAxis");
		Vector3d vecDirY = manip_pos->GetProperties()->GetVector("YAxis");
		csys[0] = vecDirX.X;
		csys[1] = vecDirX.Y;
		csys[2] = vecDirX.Z;
		csys[3] = vecDirY.X;
		csys[4] = vecDirY.Y;
		csys[5] = vecDirY.Z;*/
        //Vector3d vecDir = directionVec->GetProperties()->GetVector("Vector");
        //double vec[3], mtx[9];
        
        /* vec[0] = vecDir.X; vec[1] = vecDir.Y; vec[2] = vecDir.Z;
        UF_MTX3_initialize_z( vec ,mtx );
        for( int idx = 0; idx < 6; ++idx )
        {
        csys[idx] = mtx[idx];
        }*/
        Point3d originPoint;
		std::vector<NXOpen::TaggedObject* > csysObjects = coord_system_pos->GetProperties()->GetTaggedObjectVector("SelectedObjects");
		if( csysObjects.size() > 0 )
		{
			tag_t csys_tag = csysObjects[0]->Tag();
			NXOpen::CoordinateSystem *coord_system = (NXOpen::CoordinateSystem *)NXOpen::NXObjectManager::Get(csys_tag);
			originPoint =  coord_system->Origin(); 
			NXOpen::NXMatrix *matrix = coord_system->Orientation();
			Matrix3x3 matrix33 = matrix->Element();
			csys[0] = matrix33.Xx;
			csys[1] = matrix33.Xy;
			csys[2] = matrix33.Xz;
			csys[3] = matrix33.Yx;
			csys[4] = matrix33.Yy;
			csys[5] = matrix33.Yz;
		}
		/*else
		{
			originPoint =  point_pos->GetProperties()->GetPoint("Point");; 
		}*/
		org[0] = originPoint.X; org[1] = originPoint.Y;org[2] = originPoint.Z;
		UF_CFI_ask_file_exist( desName, &status);
        if( 0 == status )
        {
            int recover = theUI->NXMessageBox()->Show("同名文件已经存在", NXOpen::NXMessageBox::DialogTypeQuestion,"是否添加实例？");
			if( 1 == recover )
			{
				UF_ASSEM_add_part_to_assembly(workPart->Tag(),desName,"TRUE",NULL,org,csys,-1,&instance,&error_status);
				UF_PART_free_load_status(&error_status);
			}
			else
				return 0;
        }
		else
		{
			StandardPartClonePart(stdModelFile.getText(), desName );
			int err = UF_ASSEM_add_part_to_assembly(workPart->Tag(),desName,"TRUE",NULL,org,csys,-1,&instance,&error_status);
			if(err)
			{
				UF_free_string_array(error_status.n_parts, error_status.file_names);
				UF_free(error_status.statuses);
				std_occ = NULL_TAG;
			}
			else
			{
				logical ispram = RoyStdData.GetCurrentStdPartIsPara();//false;//
                tag_t work_occ, std_tag;
                StlNXStringVector assoAttrNames = RoyStdData.GetAssoAttrNames();
                StlNXStringVector assoAttrValues= RoyStdData.GetAssoAttrValues();
                NXString classall = RoyStdData.GetCurrentStdClassName();
                work_occ = UF_ASSEM_ask_work_occurrence();
                std_tag = UF_ASSEM_ask_child_of_instance(instance);
                std_occ = UF_ASSEM_ask_part_occ_of_inst(work_occ, instance);
                UF_ASSEM_set_work_occurrence(std_occ);	
                if(ispram)
				{
					//参数化驱动
					Royal_STD_parametrize_part( all_express, std_tag);
				}
                Royal_set_obj_attr(std_tag, "标准件分类", classall.GetText());
                Royal_create_STD_attributes(std_tag,assoAttrNames,assoAttrValues);
                UF_ASSEM_set_work_part(workPart->Tag());
			}
			UF_PART_free_load_status(&error_status);
		}
        if(NULL_TAG != instance)
		{
			logical ispocket = toggle_pocket->GetProperties()->GetLogical("Value");//false;//
			if( ispocket )
			{
                std::vector<NXOpen::TaggedObject* > objects = bodyForcePock->GetProperties()->GetTaggedObjectVector("SelectedObjects");
				if( NULL_TAG == std_occ )
				{
					tag_t work_occ = NULL_TAG;
					work_occ = UF_ASSEM_ask_work_occurrence();
					std_occ = UF_ASSEM_ask_part_occ_of_inst(work_occ, instance);
				}
				StlTagVector target_list;
				StlTagVector target_force;
                for( int idx = 0; idx < objects.size(); ++idx )
                    target_force.push_back(objects[idx]->Tag());
				CF_GetCurrentPartSolidBodies(target_list);
				Royal_standard_pocket(std_occ,target_list,target_force);
			}
		}
        //UF_PART_save();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}

void RYStandardPart::SetStdDefaultName()
{
	char fileName[133] = "";
	logical isparame = RoyStdData.GetCurrentStdPartIsPara();
	NXString modelfile = RoyStdData.GetCurrentStdPartModel();
	const char* orgname = modelfile.GetText();
	uc4574(orgname, 2, fileName);
	if( isparame )
	{
		StlLogicalVector expRenameFlag = RoyStdData.GetCurrentExpRename();
		StlNXStringVector expressions = list_box0->GetProperties()->GetStrings("ListItems");
		for( int idx = 0; idx < expRenameFlag.size(); ++idx )
		{
			if( expRenameFlag[idx] )
			{
				NXString leftStr, rightStr;
				ROY_dissect_exp_string(expressions[idx].GetText(),leftStr, rightStr);
                strcat(fileName,"-");
				strcat(fileName,leftStr.GetText());
				strcat(fileName,rightStr.GetText());
			}
		}
	}
	//strcat(fileName,"_01");
	stdPartName->GetProperties()->SetString("Value",fileName);
}
void RYStandardPart::UpdateExpUI( )
{
	StlNXStringVector expressions;
	logical isparame = RoyStdData.GetCurrentStdPartIsPara();
	group_paras->GetProperties()->SetLogical("Show",isparame);
	logical ispocket = RoyStdData.GetCurrentStdPartIsPock();
	toggle_pocket->GetProperties()->SetLogical("Show",ispocket);
	NXString bmp = RoyStdData.GetCurrentStdPartBitmap();
	label_legend->GetProperties()->SetString("Bitmap",bmp);
	
	if(isparame)
	{
		StlNXStringVector expressionNames = RoyStdData.GetCurrentExpNames();
		StlNXStringVectorVector expValues = RoyStdData.GetCurrentExpValues();
		expressions = RoyStdData.GetLastUIExpressions();
		if( expressions.size() < 1 )
		{
			for( int kdx = 0; kdx < expressionNames.size(); ++kdx )
			{
				if( expValues[kdx].size() > 0 )
				{
					expressions.push_back(expressionNames[kdx]+"="+expValues[kdx].at(0));
				}
			}
		}
		UI_ListBox_SetItems(list_box0,expressions);
		list_box0->GetProperties()->SetInteger("SelectedItemIndex",0);
		StlDoubleVector valuelist;
		for( int kdx = 0; kdx < expValues[0].size(); ++kdx )
		{
			valuelist.push_back(atof(expValues[0].at(kdx).GetText()));
		}
		if( valuelist.size() > 0 )
		{
			logical expcankeyin = RoyStdData.GetCurrentExpCanInput().at(0);
			if( expcankeyin )
			{
				double_para->GetProperties()->SetLogical("Show",true);
				enum_nokeyinPara->GetProperties()->SetLogical("Show",false);
				double_para->GetProperties()->SetDoubleVector("ComboOptions",valuelist);
				double value = 0;
				EF_eval_exp(expressions[0].GetLocaleText(),&value);
				UI_DoubleSetValue(double_para,value);
				double_para->GetProperties()->SetString("Label",expressionNames[0]);
			}
			else
			{
				double_para->GetProperties()->SetLogical("Show",false);
				enum_nokeyinPara->GetProperties()->SetLogical("Show",true);
				enum_nokeyinPara->GetProperties()->SetEnumMembers("Value",expValues[0]);
				enum_nokeyinPara->GetProperties()->SetString("Label",expressionNames[0]);
				double value = 0;
				char str[64]="";
				EF_eval_exp(expressions[0].GetLocaleText(),&value);
				sprintf_s(str,"%g",value);
				enum_nokeyinPara->GetProperties()->SetEnumAsString("Value",str);
			}
		}
	}// end of if(isparame)

	SetStdDefaultName();
}


//------------------------------------------------------------------------------
//Callback Name: update_cb
//------------------------------------------------------------------------------
int RYStandardPart::update_cb(NXOpen::BlockStyler::UIBlock* block)
{
    try
    {
        if(block == string_search)
        {
            StlNXStringVector results,namestosearch;
            NXString key = string_search->GetProperties()->GetString("Value");
            char* keystr = UTF8ToANSI(key.GetText());
            namestosearch =RoyStdData.GetStandardSearchDataName();
            for( int idx = 0; idx < namestosearch.size(); ++idx )
            {
                if(IsContainStr(namestosearch[idx].GetText(),keystr))
                {
                    results.push_back(namestosearch[idx]);
                }
            }
            UI_ListBox_SetItems(list_search_result,results);
        }
        else if(block == button_search)
        {
        //---------Enter your code here-----------
        }
        else if(block == list_search_result)
        {
            StlNXStringVector namestosearch;
            int idx1 = 0, idx2 = 0, idx3 = 0;
            //int idx = list_search_result->GetProperties()->GetInteger("SelectedItemIndex");
            int idx4 = list_search_result->GetProperties()->GetInteger("SelectedItemIndex");
			StlNXStringVector listitems = list_search_result->GetProperties()->GetStrings("ListItems");
            const char* selectResult = UTF8ToANSI(listitems[idx4].GetUTF8Text());
            namestosearch =RoyStdData.GetStandardSearchDataName();
            for( int idx = 0; idx < namestosearch.size(); ++idx )
            {
                if( 0 == strcmp(selectResult,namestosearch[idx].GetText()) )
                {
                    RoyStdData.GetStandardSearchDataIndex(idx,&idx1,&idx2,&idx3);
                    break;
                }
            }
            RoyStdData.RefreshData(idx1,idx2,idx3);
            enum_1->GetProperties()->SetEnumMembers("Value", RoyStdData.GetFirstClassNames());
            enum_2->GetProperties()->SetEnumMembers("Value", RoyStdData.GetSecondClassNames());
			enum_3->GetProperties()->SetEnumMembers("Value", RoyStdData.GetThirdClassNames());
            enum_1->GetProperties()->SetEnum("Value",idx1);
            enum_2->GetProperties()->SetEnum("Value",idx2);
            enum_3->GetProperties()->SetEnum("Value",idx3);
            UpdateExpUI();
        }
        else if(block == select_std_edit)
        {
        //---------Enter your code here-----------
        }
        else if(block == enum_1)
        {
        //---------Enter your code here-----------
			int idx = enum_1->GetProperties()->GetEnum("Value");
			RoyStdData.RefreshData(idx,0,0);
			enum_2->GetProperties()->SetEnumMembers("Value", RoyStdData.GetSecondClassNames());
			enum_3->GetProperties()->SetEnumMembers("Value", RoyStdData.GetThirdClassNames());
			UpdateExpUI();
        }
        else if(block == enum_2)
        {
        //---------Enter your code here-----------
			int idx1 = enum_1->GetProperties()->GetEnum("Value");
			int idx2 = enum_2->GetProperties()->GetEnum("Value");
			RoyStdData.RefreshData(idx1,idx2,0);
			enum_3->GetProperties()->SetEnumMembers("Value", RoyStdData.GetThirdClassNames());
			UpdateExpUI();
        }
        else if(block == enum_3)
        {
        //---------Enter your code here-----------
			int idx1 = enum_1->GetProperties()->GetEnum("Value");
			int idx2 = enum_2->GetProperties()->GetEnum("Value");
			int idx3 = enum_3->GetProperties()->GetEnum("Value");
			RoyStdData.RefreshData(idx1,idx2,idx3);
			UpdateExpUI();
        }
        else if(block == parentNode)
        {
        //---------Enter your code here-----------
        }
        else if(block == stdPartName)
        {
        //---------Enter your code here-----------
        }
        else if(block == label_legend)
        {
        //---------Enter your code here-----------
        }
        else if(block == list_box0)
        {
        //---------Enter your code here-----------
			int idx1 = enum_1->GetProperties()->GetEnum("Value");
			int idx2 = enum_2->GetProperties()->GetEnum("Value");
			int idx3 = enum_3->GetProperties()->GetEnum("Value");
			int idx4 = list_box0->GetProperties()->GetInteger("SelectedItemIndex");
			StlNXStringVectorVector expValues = RoyStdData.GetCurrentExpValues();
			StlDoubleVector valuelist;
			for( int kdx = 0; kdx < expValues[idx4].size(); ++kdx )
			{
				valuelist.push_back(atof(expValues[idx4].at(kdx).GetText()));
			}
			logical expcankeyin = RoyStdData.GetCurrentExpCanInput().at(idx4);
			StlNXStringVector listitems = list_box0->GetProperties()->GetStrings("ListItems");
			NXString leftStr, rightStr;
			ROY_dissect_exp_string(listitems[idx4].GetLocaleText(),leftStr, rightStr);
			if( expcankeyin )
			{
				double_para->GetProperties()->SetLogical("Show",true);
				enum_nokeyinPara->GetProperties()->SetLogical("Show",false);
				double_para->GetProperties()->SetDoubleVector("ComboOptions",valuelist);
				UI_DoubleSetValue(double_para,atof(rightStr.GetLocaleText()));
				double_para->GetProperties()->SetString("Label",leftStr.GetLocaleText());
			}
			else
			{
				double_para->GetProperties()->SetLogical("Show",false);
				enum_nokeyinPara->GetProperties()->SetLogical("Show",true);
				enum_nokeyinPara->GetProperties()->SetEnumMembers("Value",expValues[idx4]);
				enum_nokeyinPara->GetProperties()->SetEnumAsString("Value",rightStr.GetLocaleText());
				enum_nokeyinPara->GetProperties()->SetString("Label",leftStr.GetLocaleText());
			}
			
        }
        else if(block == double_para)
        {
        //---------Enter your code here-----------
			int idx = list_box0->GetProperties()->GetInteger("SelectedItemIndex");
			if( idx > -1 )
			{
				double curval = double_para->GetProperties()->GetDouble("Value");
				NXString curname = double_para->GetProperties()->GetString("Label");
				StlNXStringVector expressions = list_box0->GetProperties()->GetStrings("ListItems");
				char str[133]="";
				sprintf(str,"%g",curval);
				expressions[idx]=NXString(curname+"="+str);
				UI_ListBox_SetItems(list_box0,expressions);
				list_box0->GetProperties()->SetInteger("SelectedItemIndex",idx);
				SetStdDefaultName();
				PrieviewAddSTD(1);
			}
        }
		else if(block == enum_nokeyinPara)
        {
        //---------Enter your code here-----------
			int idx = list_box0->GetProperties()->GetInteger("SelectedItemIndex");
			if( idx < 0 )
				return 0;
			NXString curval = enum_nokeyinPara->GetProperties()->GetEnumAsString("Value");
			NXString curname = enum_nokeyinPara->GetProperties()->GetString("Label");
			StlNXStringVector expressions = list_box0->GetProperties()->GetStrings("ListItems");
			expressions[idx]=NXString(curname+"="+curval);
			if( 0 == idx && RoyStdData.GetIsSpecialParamsTable() )
			{
				int paramidx = enum_nokeyinPara->GetProperties()->GetEnum("Value");
				RoyStdData.SetSpecialParamIndex(paramidx);
				int idx1 = enum_1->GetProperties()->GetEnum("Value");
				int idx2 = enum_2->GetProperties()->GetEnum("Value");
				int idx3 = enum_3->GetProperties()->GetEnum("Value");
				StlNXStringVector expressionNames = RoyStdData.GetCurrentExpNames();
				StlNXStringVectorVector expValues = RoyStdData.GetCurrentExpValues();
				for( int kdx = 1; kdx < expressions.size(); ++kdx )
				{
					if( expValues[kdx].size() > 0 )
					{
						expressions[kdx] = (expressionNames[kdx]+"="+expValues[kdx].at(0));
					}
				}
				
			}
			UI_ListBox_SetItems(list_box0,expressions);
			list_box0->GetProperties()->SetInteger("SelectedItemIndex",idx);
			SetStdDefaultName();
			PrieviewAddSTD(1);
        }
        else if(block == point_pos)
        {
        //---------Enter your code here-----------
			/*tag_t csys = NULL_TAG;
			tag_t matrix = NULL_TAG;
			double csys_matrix[9],origin[3]={0,0,0};

			Point3d pt = point_pos->GetProperties()->GetPoint("Point");
			UF_CSYS_create_matrix(csys_matrix, &matrix);
			UF_CSYS_create_csys(origin, matrix, &csys);

			NXOpen::CoordinateSystem *coord_system = (NXOpen::CoordinateSystem *)NXOpen::NXObjectManager::Get(csys);

			std::vector <TaggedObject*> vcsys;
			vcsys.push_back(coord_system);
			coord_system_pos->GetProperties()->SetTaggedObjectVector("SelectedObjects",vcsys);*/
			//CreateCoordinateSystem(Xform, SmartObject.UpdateOption)

			//coord_system_pos->GetProperties()->
        }
        else if(block == coord_system_pos)
        {
        //---------Enter your code here-----------
			/*tag_t csys_tag = NULL_TAG;
			std::vector<NXOpen::TaggedObject* > csysObjects = coord_system_pos->GetProperties()->GetTaggedObjectVector("SelectedObjects");
			if( csysObjects.size() > 0 )
			{
				csys_tag = csysObjects[0]->Tag();
			}
			//NXOpen::CoordinateSystem *coord_system  = dynamic_cast<NXOpen::CoordinateSystem*>(coord_system_pos->Tag);
			NXOpen::CoordinateSystem *coord_system = (NXOpen::CoordinateSystem *)NXOpen::NXObjectManager::Get(csys_tag);
			// Origin of the selected CSYS :
			NXOpen::Point3d origin =  coord_system->Origin(); 

			point_pos->GetProperties()->SetPoint("Point",origin);

			//Part *displayPart = theSession->Parts()->Display();
			// Orientation  Matrix :  
			NXOpen::NXMatrix *matrix = coord_system->Orientation();

			NXOpen::Matrix3x3 mx3 = matrix->Element();*/
			if( first > 0 )
			{
				PrieviewAddSTD(0);
			}
			else
			{
				first++;
			}
        }
        else if(block == manip_pos)
        {
        //---------Enter your code here-----------
			
        }
        else if(block == toggle_pocket)
        {
        //---------Enter your code here-----------
        }
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}

int RYStandardPart::cancel_cb()
{
    try
    {
        //---- Enter your callback code here -----
		if(NULL_TAG != stdPreviewInstance && newCopy )
		{
			char part_fspec1[ MAX_FSPEC_BUFSIZE ]="";
			tag_t cur_preview_std_tag = UF_ASSEM_ask_child_of_instance(stdPreviewInstance);
			UF_PART_ask_part_name(cur_preview_std_tag,part_fspec1);
			uc4561(part_fspec1,2);
		}
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}
//------------------------------------------------------------------------------
//Callback Name: ok_cb
//------------------------------------------------------------------------------
int RYStandardPart::ok_cb()
{
    int errorCode = 0;
    try
    {
        errorCode = apply_cb();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        RYStandardPart::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}
//------------------------------------------------------------------------------
//ListBox specific callbacks
//------------------------------------------------------------------------------
//int RYStandardPart::AddCallback (NXOpen::BlockStyler::ListBox* list_box)
//{
//}

//int RYStandardPart::DeleteCallback(NXOpen::BlockStyler::ListBox* list_box)
//{
//}

//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//Function Name: GetBlockProperties
//Description: Returns the propertylist of the specified BlockID
//------------------------------------------------------------------------------
PropertyList* RYStandardPart::GetBlockProperties(const char *blockID)
{
    return theDialog->GetBlockProperties(blockID);
}
