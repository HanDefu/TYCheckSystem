//==============================================================================
//  WARNING!!  This file is overwritten by the Block Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  E:\Project\WetTang\Src\WeiTang\install\application\TYBaiWeiXian.cpp
//
//        This file was generated by the NX Block Styler
//        Created by: Administrator
//              Version: NX 7
//              Date: 07-28-2019  (Format: mm-dd-yyyy)
//              Time: 18:55 (Format: hh-mm)
//
//==============================================================================

//==============================================================================
//  Purpose:  This TEMPLATE file contains C++ source to guide you in the
//  construction of your Block application dialog. The generation of your
//  dialog file (.dlx extension) is the first step towards dialog construction
//  within NX.  You must now create a NX Open application that
//  utilizes this file (.dlx).
//
//  The information in this file provides you with the following:
//
//  1.  Help on how to load and display your Block Styler dialog in NX
//      using APIs provided in NXOpen.BlockStyler namespace
//  2.  The empty callback methods (stubs) associated with your dialog items
//      have also been placed in this file. These empty methods have been
//      created simply to start you along with your coding requirements.
//      The method name, argument list and possible return values have already
//      been provided for you.
//==============================================================================

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include "TYBaiWeiXian.hpp"
#include <uf_curve.h>
#include <uf_obj.h>
#include "../Common/Com_UG.h"
#include <uf_vec.h>
#include <uf_drf.h>
#include <NXOpen/Session.hxx>
#include <NXOpen/Part.hxx>
#include <NXOpen/PartCollection.hxx>
#include <NXOpen/Annotations_DraftingNoteBuilder.hxx>
#include <NXOpen/ViewCollection.hxx>
#include <NXOpen/View.hxx>
#include <uf_part.h>
#include <uf_assem.h>
#include <uf_csys.h>
#include "../Common/Com_UI.h"
#include <NXOpen/WCS.hxx>
#include <NXOpen/Annotations_SimpleDraftingAid.hxx>
#include <NXOpen/Annotations_AnnotationManager.hxx>
#include <NXOpen/FontCollection.hxx>
#include <NXOpen/PointCollection.hxx>
#include <NXOpen/ModelingViewCollection.hxx>
#include <NXOpen/ModelingView.hxx>
#include <NXOpen/SelectDisplayableObject.hxx>

using namespace NXOpen;
using namespace NXOpen::BlockStyler;


static void MappingPointToComponentPart(std::vector<Point3d> &org, std::vector<Point3d> &des);
static void GetNewMatrix(tag_t edge1, tag_t edge2, tag_t face, double Matrix[9], double origin[3]);
static logical ROY_is_face_parallel_XYZ(tag_t face, int& xyz);
static tag_t CreateLine( Point3d startpoint,Point3d endpoint );
static tag_t CreateNoteText2(char* textStr,double textHei, Point3d coordinate1,Point3d coordinate2,double origin[3] /*角点*/, double csys_mtx[9]);
static int CreateNoteText3(char* textStr,double textHei, Point3d coordinate1,Point3d coordinate2,double origin[3] /*角点*/, double csys_mtx[9]);
//------------------------------------------------------------------------------
// Initialize static variables
//------------------------------------------------------------------------------
Session *(TYBaiWeiXian::theSession) = NULL;
UI *(TYBaiWeiXian::theUI) = NULL;

//------------------------------------------------------------------------------
// Declaration of global variables
//------------------------------------------------------------------------------
TYBaiWeiXian *theTYBaiWeiXian;
//------------------------------------------------------------------------------
// Constructor for NX Styler class
//------------------------------------------------------------------------------
TYBaiWeiXian::TYBaiWeiXian()
{
	try
	{
		// Initialize the NX Open C++ API environment
		TYBaiWeiXian::theSession = NXOpen::Session::GetSession();
		TYBaiWeiXian::theUI = UI::GetUI();
		theDialogName = "TYBaiWeiXian.dlx";
		theDialog = TYBaiWeiXian::theUI->CreateDialog(theDialogName.c_str());
		// Registration of callback functions
		theDialog->AddApplyHandler(make_callback(this, &TYBaiWeiXian::apply_cb));
		theDialog->AddOkHandler(make_callback(this, &TYBaiWeiXian::ok_cb));
		theDialog->AddUpdateHandler(make_callback(this, &TYBaiWeiXian::update_cb));
		theDialog->AddCancelHandler(make_callback(this, &TYBaiWeiXian::cancel_cb));
		theDialog->AddFilterHandler(make_callback(this, &TYBaiWeiXian::filter_cb));
		theDialog->AddInitializeHandler(make_callback(this, &TYBaiWeiXian::initialize_cb));
		theDialog->AddDialogShownHandler(make_callback(this, &TYBaiWeiXian::dialogShown_cb));
	}
	catch(exception& ex)
	{
		//---- Enter your exception handling code here -----
		throw;
	}
}

//------------------------------------------------------------------------------
// Destructor for NX Styler class
//------------------------------------------------------------------------------
TYBaiWeiXian::~TYBaiWeiXian()
{
	if (theDialog != NULL)
	{
		delete theDialog;
		theDialog = NULL;
	}
}

int TYBaiWeiXian::Show()
{
	try
	{
		theDialog->Show();
	}
	catch(exception& ex)
	{
		//---- Enter your exception handling code here -----
		TYBaiWeiXian::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
	}
	return 0;
}


//------------------------------------------------------------------------------
//Method name: Show_TYBaiWeiXian
//------------------------------------------------------------------------------
void TYBaiWeiXian::Show_TYBaiWeiXian()
{
	try
	{
		theTYBaiWeiXian = new TYBaiWeiXian();
		// The following method shows the dialog immediately
		theTYBaiWeiXian->Show();
	}
	catch(exception& ex)
	{
		//---- Enter your exception handling code here -----
		TYBaiWeiXian::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
	}
	delete theTYBaiWeiXian;
}

//------------------------------------------------------------------------------
//---------------------Block Styler Callback Functions--------------------------
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//Callback Name: initialize_cb
//------------------------------------------------------------------------------
void TYBaiWeiXian::initialize_cb()
{
	try
	{
		groupSelect = theDialog->TopBlock()->FindBlock("groupSelect");
		edgeX = theDialog->TopBlock()->FindBlock("edgeX");
		edgeY = theDialog->TopBlock()->FindBlock("edgeY");
		pointOrigin = theDialog->TopBlock()->FindBlock("pointOrigin");
		groupSetting = theDialog->TopBlock()->FindBlock("groupSetting");
		enumDist = theDialog->TopBlock()->FindBlock("enumDist");
		enumStartXMaxDist = theDialog->TopBlock()->FindBlock("enumStartXMaxDist");
		enumStartYMaxDist = theDialog->TopBlock()->FindBlock("enumStartYMaxDist");
		enumTextHeight = theDialog->TopBlock()->FindBlock("enumTextHeight");
		toggleYX = theDialog->TopBlock()->FindBlock("toggleYX");

	}
	catch(exception& ex)
	{
		//---- Enter your exception handling code here -----
		TYBaiWeiXian::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
	}
}

//------------------------------------------------------------------------------
//Callback Name: dialogShown_cb
//This callback is executed just before the dialog launch. Thus any value set 
//here will take precedence and dialog will be launched showing that value. 
//------------------------------------------------------------------------------
void TYBaiWeiXian::dialogShown_cb()
{
	try
	{
		//---- Enter your callback code here -----
	}
	catch(exception& ex)
	{
		//---- Enter your exception handling code here -----
		TYBaiWeiXian::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
	}
}

//------------------------------------------------------------------------------
//Callback Name: apply_cb
//------------------------------------------------------------------------------
int TYBaiWeiXian::apply_cb()
{
	try
	{
		//---- Enter your callback code here -----
		int xyz = 0;
		vtag_t lineandText;
		tag_t face = NULL_TAG;
		NXOpen::Session *theSession = NXOpen::Session::GetSession();
		NXOpen::Part *workPart(theSession->Parts()->Work());
		
		int sel = 0;
		int firstDisX = 0;
		int firstDisY = 0;
		UI_EnumGetCurrentSel(enumStartXMaxDist,sel);
		if (sel == 0)
			firstDisX = 50;
		else
			firstDisX = 100;

		UI_EnumGetCurrentSel(enumStartYMaxDist,sel);
		if (sel == 0)
			firstDisY = 50;
		else
			firstDisY = 100;


		int kexianjianju = 0;
		UI_EnumGetCurrentSel(enumDist,sel);
		if (sel == 0)
			kexianjianju = 50;
		else if (sel == 1)
			kexianjianju = 100;
		else
			kexianjianju = 200;

		double txtHei = 5;
		UI_EnumGetCurrentSel(enumTextHeight,sel);
		if (sel == 0)
			txtHei = 5;
		else if (sel == 1)
			txtHei = 6;
		else if (sel == 2)
			txtHei = 8;
		else if (sel == 3)
			txtHei = 10;

		double csys_mtx[9]={1,0,0,0,1,0,0,0,1};
		std::vector<NXOpen::TaggedObject* > objects = UI_GetSelectObjects(edgeX);
		std::vector<NXOpen::TaggedObject* > objects1 =  UI_GetSelectObjects(edgeY);

		if(objects.size() > 0 && objects1.size() > 0)
		{
			tag_t edge1 = objects[0]->Tag();
			tag_t edge2 = objects1[0]->Tag();
			TYCOM_AskEdgeEdgeFace(edge1,edge2,face);
			if(NULL_TAG == face )
			{
				uc1601("选择的边不在同一平面,请重新选择",1);
				return 0;
			}
			//CF_CurveGetObjectIntersectPoint(edge1,edge2,origin,ref);
			GetNewMatrix(edge1,edge2,face,csys_mtx,origin);
		}
		if( firstDisX > kexianjianju )
			firstDisX = kexianjianju;
		initpoints();
		logical ispraXYZ = ROY_is_face_parallel_XYZ(face,xyz);
		if(ispraXYZ)
		{
			const double kedutol = 0.5;
			tag_t part_tag = UF_PART_ask_display_part();
			tag_t prework = UF_PART_ask_display_part();
			logical isAssemEnv = UF_ASSEM_is_occurrence(face);
			Vector3d vecDirX(1,0,0);
			Vector3d vecDirY(0,1,0);
			double min_corner[3]={0.0},directions[3][3]={0.0},distances[3] = {0.0},startPoint[3]={0.0},endPoint[3]={0.0};
			UF_MODL_ask_bounding_box_exact( face, NULL_TAG, min_corner, directions, distances );
			if( 1 == xyz || 0 == xyz) //+Z -Z
			{
				double point1x[3],point2x[3],point1xx[3],point2xx[3];
				int nn = 0;
				if( min_corner[0]+50 >= 0 )
					nn = (min_corner[0]+50)/50;
				else
					nn = (min_corner[0])/50;
				int mm = 0;
				if( min_corner[1]+50 >= 0 )
					mm = (min_corner[1]+50)/50;
				else
					mm = (min_corner[1])/50;
				double xkedu = nn*50;
				double ykedu = mm*50;
				while( (xkedu - min_corner[0]) <= (firstDisX-50))
				{
					xkedu+=50;
				}
				while( (ykedu - min_corner[1]) <= (firstDisY-50))
				{
					ykedu+=50;
				}
				while(xkedu < (min_corner[0]+distances[0]-kedutol))
				{
					startPoint[0] = xkedu;
					startPoint[1] = min_corner[1];
					startPoint[2] = min_corner[2];
					endPoint[0] = xkedu;
					endPoint[1] = min_corner[1]+distances[1];
					endPoint[2] = min_corner[2];
					Point3d lineStartPt(startPoint[0],startPoint[1],startPoint[2]);
					Point3d lineEndPt(endPoint[0],endPoint[1],endPoint[2]);
					lineXStart.push_back(lineStartPt);
					lineXEnd.push_back(lineEndPt);
					xkedu = xkedu+kexianjianju;
				}
				while(ykedu < (min_corner[1]+distances[1]-kedutol))
				{
					startPoint[0] = min_corner[0];
					startPoint[1] = ykedu;
					startPoint[2] = min_corner[2];
					endPoint[0] = min_corner[0]+distances[0];
					endPoint[1] = ykedu;
					endPoint[2] = min_corner[2];
					Point3d lineStartPt(startPoint[0],startPoint[1],startPoint[2]);
					Point3d lineEndPt(endPoint[0],endPoint[1],endPoint[2]);
					lineYStart.push_back(lineStartPt);
					lineYEnd.push_back(lineEndPt);
					ykedu = ykedu+kexianjianju;
				}
			}
			else if( 2 == xyz || 4 == xyz )//xz plane -y,+y
			{
				int idx = 1,jdx = 1;
				double point1x[3],point2x[3],point1xx[3],point2xx[3];
				int nn = 0;
				if( min_corner[0]+50 >= 0 )
					nn = (min_corner[0]+50)/50;
				else
					nn = (min_corner[0])/50;
				int mm = 0;
				if( min_corner[2]+50 >= 0 )
					mm = (min_corner[2]+50)/50;
				else
					mm = (min_corner[2])/50;
				double xkedu = nn*50;
				double ykedu = mm*50;
				while( (xkedu - min_corner[0]) <= (firstDisX-50))
				{
					xkedu+=50;
				}
				while( (ykedu - min_corner[2]) <= (firstDisY-50))
				{
					ykedu+=50;
				}

				while(xkedu < (min_corner[0]+distances[0]-kedutol))
				{
					startPoint[0] = xkedu;
					startPoint[1] = min_corner[1];
					startPoint[2] = min_corner[2];
					endPoint[0] = xkedu;
					endPoint[1] = min_corner[1];
					endPoint[2] = min_corner[2]+distances[2];
					Point3d lineStartPt(startPoint[0],startPoint[1],startPoint[2]);
					Point3d lineEndPt(endPoint[0],endPoint[1],endPoint[2]);
					lineXStart.push_back(lineStartPt);
					lineXEnd.push_back(lineEndPt);
					xkedu += kexianjianju;
				}
				while(ykedu < (min_corner[2]+distances[2]-kedutol))
				{
					startPoint[0] = min_corner[0];
					startPoint[1] = min_corner[1];
					startPoint[2] = ykedu;
					endPoint[0] = min_corner[0]+distances[0];
					endPoint[1] = min_corner[1];
					endPoint[2] = ykedu;
					Point3d lineStartPt(startPoint[0],startPoint[1],startPoint[2]);
					Point3d lineEndPt(endPoint[0],endPoint[1],endPoint[2]);
					lineZStart.push_back(lineStartPt);
					lineZEnd.push_back(lineEndPt);
					ykedu += kexianjianju;
				}
			}
			else if( 3 == xyz || 5 == xyz )//YZ PLANE +x,-x
			{
				int idx = 1,jdx = 1;
				double point1x[3],point2x[3],point1xx[3],point2xx[3];
				int nn = 0;
				if( min_corner[1]+50 >= 0 )
					nn = (min_corner[1]+50)/50;
				else
					nn = (min_corner[1])/50;
				int mm = 0;
				if( min_corner[2]+50 >= 0 )
					mm = (min_corner[2]+50)/50;
				else
					mm = (min_corner[2])/50;
				double xkedu = nn*50;
				double ykedu = mm*50;
				while( (xkedu - min_corner[1]) <= (firstDisX-50))
				{
					xkedu+=50;
				}
				while( (ykedu - min_corner[2]) <= (firstDisY-50))
				{
					ykedu+=50;
				}
				while(xkedu < (min_corner[1]+distances[1]-kedutol))
				{
					startPoint[0] = min_corner[0];
					startPoint[1] = xkedu;
					startPoint[2] = min_corner[2];
					endPoint[0] = min_corner[0];
					endPoint[1] = xkedu;
					endPoint[2] = min_corner[2]+distances[2];
					Point3d lineStartPt(startPoint[0],startPoint[1],startPoint[2]);
					Point3d lineEndPt(endPoint[0],endPoint[1],endPoint[2]);
					lineYStart.push_back(lineStartPt);
					lineYEnd.push_back(lineEndPt);
					xkedu += kexianjianju;
				}
				while(ykedu < (min_corner[2]+distances[2]-kedutol))
				{
					startPoint[0] = min_corner[0];
					startPoint[1] = min_corner[1];
					startPoint[2] = ykedu;
					endPoint[0] = min_corner[0];
					endPoint[1] = min_corner[1]+distances[1];
					endPoint[2] = ykedu;
					Point3d lineStartPt(startPoint[0],startPoint[1],startPoint[2]);
					Point3d lineEndPt(endPoint[0],endPoint[1],endPoint[2]);
					lineZStart.push_back(lineStartPt);
					lineZEnd.push_back(lineEndPt);
					ykedu += kexianjianju;
				}
			}

			if(isAssemEnv)
			{
				//UF_ASSEM_set_work_part(prework);
				tag_t partocc = part_tag = UF_ASSEM_ask_part_occurrence(face);
				if(UF_ASSEM_is_occurrence(partocc))
					part_tag = UF_ASSEM_ask_prototype_of_occ(partocc);
				UF_ASSEM_set_work_part(part_tag);
				MappingPointsToComponentPart();
				UF_PART_set_display_part(part_tag);
				workPart = theSession->Parts()->Work();

			}
			else
			{
				MappingPointsToComponentPart();
			} 
			tag_t oldcsys = NULL_TAG;
			UF_CSYS_ask_wcs(&oldcsys);
			tag_t new_csys = NULL_TAG;
			tag_t matrix = NULL_TAG;
			//double org[3]={0};
			UF_CSYS_create_matrix(csys_mtx,&matrix);
			UF_CSYS_create_csys( origin, matrix, &new_csys );
			UF_CSYS_set_wcs( new_csys );//UF_CSYS_set_origin
			char str[133]="";
			for( int idx = 0; idx < lineXStartMapped.size(); ++idx )
			{
				tag_t line = CreateLine(lineXStartMapped[idx],lineXEndMapped[idx]);
				AddTagToVector(line,lineandText);
				sprintf(str,"X%0.0f",lineXStart[idx].X);
				tag_t text = CreateNoteText3(str,txtHei,lineXStartMapped[idx],lineXEndMapped[idx],originRectMapped,csys_mtx);
				AddTagToVector(text,lineandText);
			}
			for( int idx = 0; idx < lineYStartMapped.size(); ++idx )
			{
				tag_t line = CreateLine(lineYStartMapped[idx],lineYEndMapped[idx]);
				AddTagToVector(line,lineandText);
				sprintf(str,"Y%0.0f",lineYStart[idx].Y);
				tag_t text = CreateNoteText3(str,txtHei,lineYStartMapped[idx],lineYEndMapped[idx],originRectMapped,csys_mtx);
				AddTagToVector(text,lineandText);
			}
			for( int idx = 0; idx < lineZStartMapped.size(); ++idx )
			{
				tag_t line = CreateLine(lineZStartMapped[idx],lineZEndMapped[idx]);
				AddTagToVector(line,lineandText);
				sprintf(str,"Z%0.0f",lineZStart[idx].Z);
				tag_t text = CreateNoteText3(str,txtHei,lineZStartMapped[idx],lineZEndMapped[idx],originRectMapped,csys_mtx);
				AddTagToVector(text,lineandText);
			}	
			CreateReferenceSet(lineandText,NXString("MODEL"));
			UF_CSYS_set_wcs( oldcsys );
			if(isAssemEnv)
			{
				UF_PART_set_display_part(prework);
			}
		}
		else
		{
			uc1601("所选平面不与XYZ平面平行",1);
			return 1;
		}
	}
	catch(exception& ex)
	{
		//---- Enter your exception handling code here -----
		TYBaiWeiXian::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
	}
	return 0;
}

//------------------------------------------------------------------------------
//Callback Name: update_cb
//------------------------------------------------------------------------------
int TYBaiWeiXian::update_cb(NXOpen::BlockStyler::UIBlock* block)
{
	try
	{
		if(block == edgeX)
		{
			//---------Enter your code here-----------
		}
		else if(block == edgeY)
		{
			//---------Enter your code here-----------
		}
		else if(block == pointOrigin)
		{
			//---------Enter your code here-----------
		}
		else if(block == enumDist)
		{
			int sel = 0;
			int firstDisX = 0;
			UI_EnumGetCurrentSel(enumStartXMaxDist,sel);
			if (sel == 0)
				firstDisX = 50;
			else
				firstDisX = 100;


			int kexianjianju = 0;
			UI_EnumGetCurrentSel(enumDist,sel);
			if (sel == 0)
				kexianjianju = 50;
			else if (sel == 1)
				kexianjianju = 100;
			else
				kexianjianju = 200;


			if(firstDisX>kexianjianju)
			{
				UI_EnumSetCurrentSel(enumStartXMaxDist,0);
			}
		}
		else if(block == enumStartXMaxDist)
		{
			int sel = 0;
			int firstDisX = 0;
			UI_EnumGetCurrentSel(enumStartXMaxDist,sel);
			if (sel == 0)
				firstDisX = 50;
			else
				firstDisX = 100;


			int kexianjianju = 0;
			UI_EnumGetCurrentSel(enumDist,sel);
			if (sel == 0)
				kexianjianju = 50;
			else if (sel == 1)
				kexianjianju = 100;
			else
				kexianjianju = 200;
			
			
			if(firstDisX>kexianjianju)
			{
				UI_EnumSetCurrentSel(enumDist,1);
			}
		}
		else if(block == enumStartYMaxDist)
		{
			
		}
		else if(block == enumTextHeight)
		{
			//---------Enter your code here-----------
		}
		else if(block == toggleYX)
		{
			//---------Enter your code here-----------
		}
	}
	catch(exception& ex)
	{
		//---- Enter your exception handling code here -----
		TYBaiWeiXian::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
	}
	return 0;
}

//------------------------------------------------------------------------------
//Callback Name: ok_cb
//------------------------------------------------------------------------------
int TYBaiWeiXian::ok_cb()
{
	try
	{
		apply_cb();
	}
	catch(exception& ex)
	{
		//---- Enter your exception handling code here -----
		TYBaiWeiXian::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
	}
	return 0;
}

//------------------------------------------------------------------------------
//Callback Name: cancel_Cb
//------------------------------------------------------------------------------
int TYBaiWeiXian::cancel_cb()
{
	try
	{
		//---- Enter your callback code here -----
	}
	catch(exception& ex)
	{
		//---- Enter your exception handling code here -----
		TYBaiWeiXian::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
	}
	return 0;
}

//------------------------------------------------------------------------------
//Callback Name: filter_cb
//------------------------------------------------------------------------------
int TYBaiWeiXian::filter_cb(NXOpen::BlockStyler::UIBlock*  block, NXOpen::TaggedObject* selectObject)
{
	return(UF_UI_SEL_ACCEPT);
}


void TYBaiWeiXian::MappingPointsToComponentPart()
{
	MappingPointToComponentPart(lineXStart,lineXStartMapped);
	MappingPointToComponentPart(lineXEnd,lineXEndMapped);
	MappingPointToComponentPart(lineYStart,lineYStartMapped);
	MappingPointToComponentPart(lineYEnd,lineYEndMapped);
	MappingPointToComponentPart(lineZStart,lineZStartMapped);
	MappingPointToComponentPart(lineZEnd,lineZEndMapped);
	Point3d orgrect;
	UI_PointGetPoint(pointOrigin,orgrect);
	double originRect[3]={orgrect.X, orgrect.Y,orgrect.Z};
	UF_CSYS_map_point(UF_CSYS_ROOT_COORDS,originRect,UF_CSYS_WORK_COORDS,originRectMapped);
}

void TYBaiWeiXian::initpoints()
{
	lineXStart.clear();
	lineXStartMapped.clear();
	lineXEnd.clear();
	lineXEndMapped.clear();

	lineYStart.clear();
	lineYStartMapped.clear();
	lineYEnd.clear();
	lineYEndMapped.clear();

	lineZStart.clear();
	lineZStartMapped.clear();
	lineZEnd.clear();
	lineZEndMapped.clear();
}



static tag_t CreateLine( Point3d startpoint,Point3d endpoint )
{
    tag_t lineTag = NULL_TAG;
    UF_CURVE_line_t line_coords;
    line_coords.start_point[0] = startpoint.X;
    line_coords.start_point[1] = startpoint.Y;
    line_coords.start_point[2] = startpoint.Z;
    line_coords.end_point[0] = endpoint.X;
    line_coords.end_point[1] = endpoint.Y;
    line_coords.end_point[2] = endpoint.Z;
    UF_CURVE_create_line(&line_coords, &lineTag);
    UF_OBJ_set_color(lineTag,186);
    return lineTag;
}

static logical ROY_is_face_parallel_XYZ(tag_t face, int& xyz)
{
    int is_parallel = false;
    double faceNormal[3]={0,0,1};
    double xyzNormal[6][3]={0,0,-1,0,0,1,0,-1,0,1,0,0,0,1,0,-1,0,0}; //-z,+z,-y,+x,+y,-x
    TYCOM_FaceAskMidPointNormal(face,faceNormal);
    for( int idx = 0; idx < 6; idx++ )
    {
        UF_VEC3_is_equal(faceNormal, xyzNormal[idx], 0.0254, &is_parallel);
        if( is_parallel )
        {
            xyz = idx;
            break;
        }
    }
    return is_parallel;
}

static tag_t CreateNoteText2(char* textStr,double textHei, Point3d coordinate1,Point3d coordinate2,double origin[3] /*角点*/, double csys_mtx[9])
{
    NXOpen::Session *theSession = NXOpen::Session::GetSession();
    NXOpen::Part *workPart(theSession->Parts()->Work());

	CartesianCoordinateSystem *oldWcs = workPart->WCS()->CoordinateSystem();
	
    NXOpen::Annotations::SimpleDraftingAid *nullNXOpen_Annotations_SimpleDraftingAid(NULL);
    NXOpen::Annotations::DraftingNoteBuilder *draftingNoteBuilder1;
    draftingNoteBuilder1 = workPart->Annotations()->CreateDraftingNoteBuilder(nullNXOpen_Annotations_SimpleDraftingAid);
    draftingNoteBuilder1->Origin()->SetAnchor(NXOpen::Annotations::OriginBuilder::AlignmentPositionBottomLeft);
    std::vector<NXString> text1;
    text1.push_back(textStr);
	double angle = 0;
    draftingNoteBuilder1->Text()->TextBlock()->SetText(text1);
    draftingNoteBuilder1->Style()->LetteringStyle()->SetGeneralTextSize(textHei);
	draftingNoteBuilder1->Style()->LetteringStyle()->SetGeneralTextCharSpaceFactor(0.5); 
    draftingNoteBuilder1->Style()->LetteringStyle()->SetGeneralTextAspectRatio(1.0);
    draftingNoteBuilder1->Style()->LetteringStyle()->SetGeneralTextLineSpaceFactor(1.0);
    int fontIndex1;
    //fontIndex1 = workPart->Fonts()->AddFont("iso-1", NXOpen::FontCollection::TypeNx);
	fontIndex1 = workPart->Fonts()->AddFont("iso-1");
    draftingNoteBuilder1->Style()->LetteringStyle()->SetGeneralTextFont(fontIndex1);

	double pt1[3]={coordinate1.X, coordinate1.Y, coordinate1.Z};
	double pt2[3]={coordinate2.X, coordinate2.Y, coordinate2.Z};
	double dist1 = 0,dist2 = 0;
	UF_VEC3_distance(pt1,origin,&dist1);
	UF_VEC3_distance(pt2,origin,&dist2);
	double offset[3]={5,5,0},offsetMapped[3]={0};

	int isPara = 0;
	double vecX[3] = {1,0,0},mag=0;
	double vecMapped[3] = {0};
	double vec[3]={coordinate2.X-coordinate1.X,coordinate2.Y-coordinate1.Y,coordinate2.Z-coordinate1.Z};
	//UF_CSYS_map_point(UF_CSYS_WORK_COORDS,offset,UF_CSYS_ROOT_COORDS,offsetMapped);
	//NXOpen::Point3d point2(coordinate1.X+offsetMapped[0], coordinate1.Y+offsetMapped[1], coordinate1.Z+offsetMapped[2]); 
	NXOpen::Point3d point2(coordinate1.X, coordinate1.Y, coordinate1.Z); 
	if( dist1 > dist2 )
	{
		/*point2.X = coordinate2.X+offsetMapped[0];
		point2.Y = coordinate2.Y+offsetMapped[1];
		point2.Z = coordinate2.Z+offsetMapped[2];*/
		point2.X = coordinate2.X;
		point2.Y = coordinate2.Y;
		point2.Z = coordinate2.Z;
		vec[0]=coordinate1.X-coordinate2.X;
		vec[1]=coordinate1.Y-coordinate2.Y;
		vec[2]=coordinate1.Z-coordinate2.Z;
	}
	UF_CSYS_map_point(UF_CSYS_ROOT_COORDS ,vecX,UF_CSYS_WORK_COORDS,vecMapped);
	UF_VEC3_unitize(vec,0.0254,&mag,vec);
	UF_VEC3_is_parallel(csys_mtx,vec,0.0254,&isPara);
	if( 0 == isPara )
	{
		int isY = 0;
		angle = 90; // Y dir mark, x-5, y+5
		UF_VEC3_is_equal(csys_mtx+3,vec,0.0254,&isY);
		point2.X=point2.X-csys_mtx[0]*5;
		point2.Y=point2.Y-csys_mtx[1]*5;
		point2.Z=point2.Z-csys_mtx[2]*5;
		if( 1 == isY ) // +Y dir
		{
			point2.X=point2.X+csys_mtx[3]*5;
			point2.Y=point2.Y+csys_mtx[4]*5;
			point2.Z=point2.Z+csys_mtx[5]*5;
		}
		else
		{
			point2.X=point2.X-csys_mtx[3]*5;
			point2.Y=point2.Y-csys_mtx[4]*5;
			point2.Z=point2.Z-csys_mtx[5]*5;
			draftingNoteBuilder1->Origin()->SetAnchor(NXOpen::Annotations::OriginBuilder::AlignmentPositionBottomRight);
		}
	}
	else  // parallel with X dir
	{
		int isX;
		UF_VEC3_is_equal(csys_mtx,vec,0.0254,&isX);
		if( 1 == isX ) // +X dir
		{
			// x+5 y+5
			point2.X=point2.X+csys_mtx[0]*5;
			point2.Y=point2.Y+csys_mtx[1]*5;
			point2.Z=point2.Z+csys_mtx[2]*5;
		}
		else
		{
			// x-5 y+5
			point2.X=point2.X-csys_mtx[0]*5;
			point2.Y=point2.Y-csys_mtx[1]*5;
			point2.Z=point2.Z-csys_mtx[2]*5;
			draftingNoteBuilder1->Origin()->SetAnchor(NXOpen::Annotations::OriginBuilder::AlignmentPositionBottomRight);
		}
		point2.X=point2.X+csys_mtx[3]*5;
		point2.Y=point2.Y+csys_mtx[4]*5;
		point2.Z=point2.Z+csys_mtx[5]*5;
	}
	
    draftingNoteBuilder1->SetTextAlignment(NXOpen::Annotations::DraftingNoteBuilder::TextAlignBelowTopExtToMaxUnderline);

	draftingNoteBuilder1->Origin()->Plane()->SetPlaneMethod(NXOpen::Annotations::PlaneBuilder::PlaneMethodTypeXyPlane);
	draftingNoteBuilder1->Origin()->SetInferRelativeToGeometry(true);

	
    
    NXOpen::Point *point1;

	draftingNoteBuilder1->Style()->LetteringStyle()->SetAngle(angle);
    
    point1 = workPart->Points()->CreatePoint(point2);
    
    NXOpen::Annotations::Annotation::AssociativeOriginData assocOrigin1;
    //assocOrigin1.OriginType = NXOpen::Annotations::AssociativeOriginTypeAtAPoint;
    assocOrigin1.OriginType = NXOpen::Annotations::AssociativeOriginTypeDrag;
    NXOpen::View *nullNXOpen_View(NULL);
    assocOrigin1.View = nullNXOpen_View;
    assocOrigin1.ViewOfGeometry = nullNXOpen_View;
    NXOpen::Point *nullNXOpen_Point(NULL);
    assocOrigin1.PointOnGeometry = nullNXOpen_Point;
    NXOpen::Annotations::Annotation *nullNXOpen_Annotations_Annotation(NULL);
    assocOrigin1.VertAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.VertAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.HorizAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.HorizAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.AlignedAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.DimensionLine = 0;
    assocOrigin1.AssociatedView = workPart->ModelingViews()->WorkView();
    assocOrigin1.AssociatedPoint = point1;
    assocOrigin1.OffsetAnnotation = nullNXOpen_Annotations_Annotation;
    assocOrigin1.OffsetAlignmentPosition = NXOpen::Annotations::AlignmentPositionTopLeft;
    assocOrigin1.XOffsetFactor = 0.0;
    assocOrigin1.YOffsetFactor = 0.0;
    assocOrigin1.StackAlignmentPosition = NXOpen::Annotations::StackAlignmentPositionAbove;
    draftingNoteBuilder1->Origin()->SetAssociativeOrigin(assocOrigin1);
    
    draftingNoteBuilder1->Origin()->Origin()->SetValue(NULL, nullNXOpen_View, point2);
    
    NXOpen::NXObject *nXObject1;
    nXObject1 = draftingNoteBuilder1->Commit();
    tag_t text = nXObject1->Tag();
    UF_OBJ_set_color(text,186);
   
    draftingNoteBuilder1->Destroy();

    return text;

}

void MappingPointToComponentPart(std::vector<Point3d> &org, std::vector<Point3d> &des)
{
	des.clear();
	for( int idx = 0; idx < org.size(); ++idx )
	{
		double pt[3]={org[idx].X,org[idx].Y,org[idx].Z};
		double pt2[3];
		UF_CSYS_map_point(UF_CSYS_ROOT_COORDS,pt,UF_CSYS_WORK_COORDS,pt2);
		Point3d pt3d(pt2[0],pt2[1],pt2[2]);
		des.push_back(pt3d);
	}
}

static void GetNewMatrix(tag_t edge1, tag_t edge2, tag_t face, double Matrix[9], double origin[3])
{
	double ref[3]={0};
	tag_t facePro = NULL_TAG;
	if(UF_ASSEM_is_occurrence(edge1))
		edge1 = UF_ASSEM_ask_prototype_of_occ(edge1);
	if(UF_ASSEM_is_occurrence(edge2))
		edge2 = UF_ASSEM_ask_prototype_of_occ(edge2);
	if(UF_ASSEM_is_occurrence(face))
		facePro = UF_ASSEM_ask_prototype_of_occ(face);
	else
		facePro = face;
	double faceNormal[3]={0,0,1};
	TYCOM_CurveGetObjectIntersectPoint(edge1,edge2,origin,ref);
	TYCOM_FaceAskMidPointNormal(facePro,faceNormal);
	double pnt1[3]={0},pnt2[3]={0},vecX[3]={0},vecY[3]={0},vecZ[3]={0},dist = 0;
	TYCOM_AskMinimumDist(edge1,edge2,dist,pnt1,pnt2);
	UF_CURVE_line_t data;
	UF_CURVE_line_t data2;
	TYCOM_CurveGetStartEndPoints(edge1, data.start_point, data.end_point);
	TYCOM_CurveGetStartEndPoints(edge2, data2.start_point, data2.end_point);
	double dis1 = 0,dis2 = 0;
	UF_VEC3_distance(pnt1, data.end_point, &dis2);
	UF_VEC3_distance(pnt1, data.start_point, &dis1);
	if( dis1 > dis2 )
	{
		vecX[0] = data.start_point[0] - pnt1[0];
		vecX[1] = data.start_point[1] - pnt1[1];
		vecX[2] = data.start_point[2] - pnt1[2];
	}
	else
	{
		vecX[0] = data.end_point[0] - pnt1[0];
		vecX[1] = data.end_point[1] - pnt1[1];
		vecX[2] = data.end_point[2] - pnt1[2];
	}
	double mag = 0;
	UF_VEC3_unitize(vecX,0.0254,&mag,vecX);
	UF_VEC3_distance(pnt2, data2.end_point, &dis2);
	UF_VEC3_distance(pnt2, data2.start_point, &dis1);
	if( dis1 > dis2 )
	{
		vecY[0] = data2.start_point[0] - pnt2[0];
		vecY[1] = data2.start_point[1] - pnt2[1];
		vecY[2] = data2.start_point[2] - pnt2[2];
	}
	else
	{
		vecY[0] = data2.end_point[0] - pnt2[0];
		vecY[1] = data2.end_point[1] - pnt2[1];
		vecY[2] = data2.end_point[2] - pnt2[2];
	}
	UF_VEC3_unitize(vecY,0.0254,&mag,vecY);
	int iseq = 0;
	UF_VEC3_cross(vecX,vecY,vecZ);
	UF_VEC3_unitize(vecZ,0.0254,&mag,vecZ);
	UF_VEC3_is_equal(faceNormal, vecZ, 0.0254, &iseq);
	if( 1 == iseq ) // equal
	{
		Matrix[0] = vecX[0];
		Matrix[1] = vecX[1];
		Matrix[2] = vecX[2];
		Matrix[3] = vecY[0];
		Matrix[4] = vecY[1];
		Matrix[5] = vecY[2];
	}
	else
	{
		Matrix[0] = vecY[0];
		Matrix[1] = vecY[1];
		Matrix[2] = vecY[2];
		Matrix[3] = vecX[0];
		Matrix[4] = vecX[1];
		Matrix[5] = vecX[2];
	}
	Matrix[6] = faceNormal[0];
	Matrix[7] = faceNormal[1];
	Matrix[8] = faceNormal[2];
}


static int CreateNoteText3(char* textStr,double textHei, Point3d coordinate1,Point3d coordinate2,double origin[3] /*角点*/, double csys_mtx[9])
{
	double pt1[3]={coordinate1.X, coordinate1.Y, coordinate1.Z};
	double pt2[3]={coordinate2.X, coordinate2.Y, coordinate2.Z};
	double dist1 = 0,dist2 = 0;
	UF_VEC3_distance(pt1,origin,&dist1);
	UF_VEC3_distance(pt2,origin,&dist2);

	int isPara = 0;
	double vecX[3] = {1,0,0},mag=0;
	double vecMapped[3] = {0};
	double vec[3]={coordinate2.X-coordinate1.X,coordinate2.Y-coordinate1.Y,coordinate2.Z-coordinate1.Z};


	NXOpen::Point3d txtPoint(coordinate1.X, coordinate1.Y, coordinate1.Z); 
	if( dist1 > dist2 )
	{
		txtPoint.X = coordinate2.X;
		txtPoint.Y = coordinate2.Y;
		txtPoint.Z = coordinate2.Z;
		vec[0]=coordinate1.X-coordinate2.X;
		vec[1]=coordinate1.Y-coordinate2.Y;
		vec[2]=coordinate1.Z-coordinate2.Z;
	}
	UF_CSYS_map_point(UF_CSYS_ROOT_COORDS ,vecX,UF_CSYS_WORK_COORDS,vecMapped);

	UF_VEC3_unitize(vec,0.0254,&mag,vec);
	UF_VEC3_is_parallel(csys_mtx,vec,0.0254,&isPara);

	double angle = 0;
	if( 0 == isPara )//所画的直线平行于X 垂直于Y轴
	{
		int isY = 0;
		angle = 90; // Y dir mark, x-5, y+5
		UF_VEC3_is_equal(csys_mtx+3,vec,0.0254,&isY);
		txtPoint.X=txtPoint.X-csys_mtx[0]*15;
		txtPoint.Y=txtPoint.Y-csys_mtx[1]*15;
		txtPoint.Z=txtPoint.Z-csys_mtx[2]*15;
		if( 1 == isY ) // +Y dir
		{
			txtPoint.X=txtPoint.X+csys_mtx[3]*10;
			txtPoint.Y=txtPoint.Y+csys_mtx[4]*10;
			txtPoint.Z=txtPoint.Z+csys_mtx[5]*10;
		}
		else
		{
			txtPoint.X=txtPoint.X-csys_mtx[3]*10;
			txtPoint.Y=txtPoint.Y-csys_mtx[4]*10;
			txtPoint.Z=txtPoint.Z-csys_mtx[5]*10;
		}
	}
	else  // 所画的直线平行于Y 垂直于X轴
	{
		int isX;
		UF_VEC3_is_equal(csys_mtx,vec,0.0254,&isX);
		if( 1 == isX ) //  直线平行于Y， 起点到终点为X+方向
		{
			// x+5 y+5
			txtPoint.X=txtPoint.X+csys_mtx[0]*20;
			txtPoint.Y=txtPoint.Y+csys_mtx[1]*20;
			txtPoint.Z=txtPoint.Z+csys_mtx[2]*20;
		}
		else//直线平行于Y， 起点到终点为X-方向
		{
			// x-5 y+5
			txtPoint.X=txtPoint.X-csys_mtx[0]*20;
			txtPoint.Y=txtPoint.Y-csys_mtx[1]*20;
			txtPoint.Z=txtPoint.Z-csys_mtx[2]*20;
		}
		txtPoint.X=txtPoint.X+csys_mtx[3]*5;
		txtPoint.Y=txtPoint.Y+csys_mtx[4]*5;
		txtPoint.Z=txtPoint.Z+csys_mtx[5]*5;
	}
    
 
	double basePnt[3] = {txtPoint.X, txtPoint.Y, txtPoint.Z};
    //UF_OBJ_set_color(text,186);
	TYText_Main2_ForBaiKeXian(textStr, basePnt, csys_mtx,textHei);

    return 0;

}