//==============================================================================
//  WARNING!!  This file is overwritten by the Block Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  D:\study\Mystudy\Pipe2015_NXopen\Src\V20150818\GetPoint.cpp
//
//        This file was generated by the NX Block Styler
//        Created by: hand
//              Version: NX 6
//              Date: 08-18-2015  (Format: mm-dd-yyyy)
//              Time: 14:56 (Format: hh-mm)
//
//==============================================================================

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include "Entry.hpp"
#include <uf.h>
#include <exception>
#include "Tool\TYRegister.hpp"
#include <NXOpen\Session.hxx>
#include "Tool\Excel\BasicExcel.hpp"
#include "UI\TYBaiWeiXian.hpp"
#include "UI\TYCheckGap.hpp"
#include "UI\TYCheckInterference.hpp"
#include "UI\TYColor.hpp"
#include "UI\TYHeavy.hpp"
#include "UI\TYHole.hpp"
#include "UI\TYMirrorText.hpp"
#include "UI\TYPrint.hpp"
#include "UI\TYProperty.hpp"
#include "UI\TYPropertyClear.hpp"
#include "UI\TYStandPart.hpp"
#include "UI\TYTextMark.hpp"
#include "Tool\TYRegister.hpp"
#include "Command.h"
#include "uf_ui.h"

using namespace NXOpen;

bool g_regOK = false;


bool InitCheck();

extern "C" DllExport void  ufusr(char *param, int *retcod, int param_len)
{
	try
	{
#ifndef ROYAL_DEBUG

		TYRegister::Show_TYRegister();//注册机相关

		if(g_regOK == 0)
		{
			UF_terminate();
			return;
		}

#endif  // ROYAL_DEBUG

		if(InitCheck() == false)
			return;

		UF_initialize();

		if(strcmp(param, "CUSTOM_TY_ADD_PROPERTY") == 0)
		{
			 TYProperty::Show_TYProperty();
		}

		if(strcmp(param, "CUSTOM_TY_COLOR_TOOL") == 0)
		{
			TYColor::Show_TYColor();
		}

		if(strcmp(param, "CUSTOM_TY_STAND_PART") == 0)
		{
			TYStandPart::Show_TYStandPart();
		}

		if(strcmp(param, "CUSTOM_TY_AUTO_DRAFTING") == 0)
		{
			TY_CMD_AutoDrafting();
		}

		if(strcmp(param, "CUSTOM_TY_BOM") == 0)
		{
			TY_CMD_Bom();
		}

		if(strcmp(param, "CUSTOM_TY_BAIKEXIAN") == 0)
		{
			TYBaiWeiXian::Show_TYBaiWeiXian();
		}

		if(strcmp(param, "CUSTOM_TY_CHECK_XUANKONG") == 0)
		{
			TYCheckGap::Show_TYCheckGap();
		}

		if(strcmp(param, "CUSTOM_TY_CHECK_INTERSECT") == 0)
		{
			TYCheckInterference::Show_TYCheckInterference();
		}

		if(strcmp(param, "CUSTOM_TY_CREATE_HOLE") == 0)
		{
			TYHole::Show_TYHole();
		}

		if(strcmp(param, "CUSTOM_TY_PRINT") == 0)
		{
			TYPrint::Show_TYPrint();
		}

		if(strcmp(param, "CUSTOM_TY_EXPORT_DWG") == 0)
		{
			TY_CMD_ExportDwg();
		}
	}
	catch(std::exception& ex)
	{
		//if ( !workPart->Preferences()->Modeling()->GetHistoryMode() )
		//{
		//throw NXException::Create("Create or edit of a Feature was recorded in History Mode but playback is in History-Free Mode.");
		//}

		//RYMirror::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
		//throw NXException::Create("生成失败.");
	}

}

//------------------------------------------------------------------------------
// This method specifies how a shared image is unloaded from memory
// within NX. This method gives you the capability to unload an
// internal NX Open application or user  exit from NX. Specify any
// one of the three constants as a return value to determine the type
// of unload to perform:
//
//
//    Immediately : unload the library as soon as the automation program has completed
//    Explicitly  : unload the library from the "Unload Shared Image" dialog
//    AtTermination : unload the library when the NX session terminates
//
//
// NOTE:  A program which associates NX Open applications with the menubar
// MUST NOT use this option since it will UNLOAD your NX Open application image
// from the menubar.
//------------------------------------------------------------------------------
extern "C" DllExport int ufusr_ask_unload()
{
	UF_terminate();
	//return (int)Session::LibraryUnloadOptionExplicitly;
	return (int)NXOpen::Session::LibraryUnloadOptionImmediately;
	//return (int)Session::LibraryUnloadOptionAtTermination;
}

//------------------------------------------------------------------------------
// Following method cleanup any housekeeping chores that may be needed.
// This method is automatically called by NX.
//------------------------------------------------------------------------------
extern "C" DllExport void ufusr_cleanup(void)
{
	try
	{
		//---- Enter your callback code here -----
	}
	catch(std::exception& ex)
	{
		//---- Enter your exception handling code here -----
	}
}

bool InitCheck()
{
	char * env = getenv("ROYAL_STANDARD_DIR");
	if (env == 0)
	{
		uc1601("没有环境变量ROYAL_STANDARD_DIR",1);
		return false;
	}

	env = getenv("UGII_USER_DIR");
	if (env == 0)
	{
		uc1601("没有环境变量ROYAL_STANDARD_DIR",1);
		return false;
	}
}